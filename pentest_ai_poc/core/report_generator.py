"""
标准漏洞报告生成器。
严格按照四字段模板生成报告，不调用 LLM，不包含免责声明、时间戳等额外信息。
"""

from datetime import datetime
from pathlib import Path

from core.logger import logger


def validate_url(url: str) -> None:
    """
    校验 URL 必须以 http:// 或 https:// 开头，否则抛出 ValueError。
    """
    if not isinstance(url, str) or not url.strip():
        raise ValueError("URL 不能为空")
    url = url.strip()
    if not url.startswith(("http://", "https://")):
        raise ValueError(f"URL 必须以 http:// 或 https:// 开头，当前: {url}")


def generate_standard_vuln_report(
    target_unit: str,
    vuln_type: str,
    url: str,
    brief_desc: str,
    poc: str,
    details: str,
) -> str:
    """
    严格按照四字段模板生成报告字符串。
    自动校验 url 是否以 http:// 或 https:// 开头，否则抛出 ValueError。

    参数:
        target_unit: 目标单位（如 "192.168.101.102" 或 "testphp.vulnweb.com"）
        vuln_type: 漏洞类型（如 "SQL 注入"）
        url: 完整的漏洞 URL（必须以 http:// 或 https:// 开头）
        brief_desc: 简要描述（1-2句话，说明漏洞本质和影响，禁止包含URL、IP、PoC等具体信息）
        poc: PoC 或 Exploit 代码（清晰、可读、可复现）
        details: 详细描述（包含复现步骤、请求/响应示例、影响范围）

    返回:
        严格符合四字段格式的报告字符串（顺序不可变）：
        漏洞标题：{target_unit}存在{vuln_type}漏洞
        漏洞URL：{url}
        简要描述：{brief_desc}
        详细细节：
        1、{details}
        2、{使用的测试组件}
        3、{poc}
    """
    # 校验 URL
    validate_url(url)

    # 构建详细细节的第2项：使用的测试组件
    test_tools = []
    if "sqlmap" in poc.lower():
        test_tools.append("sqlmap")
    if "burp" in poc.lower() or "burpsuite" in poc.lower():
        test_tools.append("Burp Suite")
    if not test_tools:
        test_tools.append("自定义脚本")

    # 组装报告（严格按照格式，顺序不可变，一字不差）
    report_lines = [
        f"漏洞标题：{target_unit}存在{vuln_type}漏洞",
        f"漏洞URL：{url}",
        f"简要描述：{brief_desc}",
        "详细细节：",
        f"1、{details}",
        f"2、使用工具：{' + '.join(test_tools)}",
        f"3、{poc}",
    ]

    return "\n".join(report_lines)


def _make_safe_target(target: str) -> str:
    """
    将目标字符串转换为适合用于文件名的安全形式。
    """
    safe_target = (
        target.replace("http://", "")
        .replace("https://", "")
        .replace("/", "_")
        .replace(":", "_")
        .replace("?", "_")
        .replace("&", "_")
        .replace("=", "_")
    )
    if not safe_target:
        safe_target = "unknown_target"
    return safe_target


def save_report_to_file(report: str, target: str) -> str:
    """
    保存漏洞验证类报告到 data/reports/{timestamp}_{target}_vuln_report.md
    返回文件名（不含路径）
    """
    # 安全化目标字符串（用于文件名）
    safe_target = _make_safe_target(target)

    # 确保报告目录存在
    reports_dir = Path(__file__).resolve().parent.parent / "data" / "reports"
    reports_dir.mkdir(parents=True, exist_ok=True)

    # 生成文件名
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{timestamp}_{safe_target}_vuln_report.md"
    filepath = reports_dir / filename

    # 保存报告（仅保存报告内容，不添加任何额外信息）
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(report)
        f.write("\n")  # 文件末尾添加一个换行符

    logger.info(f"[report_generator] Report saved to {filepath}")
    return filename


def save_ai_report_to_file(report: str, target: str) -> str:
    """
    保存 AI 总结类渗透报告到 data/reports/{timestamp}_{target}_ai_report.md
    返回文件名（不含路径）
    """
    safe_target = _make_safe_target(target)

    reports_dir = Path(__file__).resolve().parent.parent / "data" / "reports"
    reports_dir.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{timestamp}_{safe_target}_ai_report.md"
    filepath = reports_dir / filename

    with open(filepath, "w", encoding="utf-8") as f:
        f.write(report)
        f.write("\n")

    logger.info(f"[report_generator] AI report saved to {filepath}")
    return filename
