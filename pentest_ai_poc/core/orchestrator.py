from __future__ import annotations

from typing import Any, Dict, List, Tuple
from urllib.parse import urlparse

from core.logger import logger
from plugins.nmap_scanner import run_nmap_fast_scan
from subagents.dirsearch_agent import DirsearchAgent
from subagents.sqli_agent import SQLiAgent
from subagents.xss_agent import XSSAgent


class Orchestrator:
    """
    协调：
    1. nmap 快速扫描
    2. 简单解析扫描结果
    注意：不再生成 AI 风险评估报告，不再检索 CVE。
    只有子 AI（如 SQLiAgent）成功验证漏洞后才生成报告。
    """

    def __init__(self) -> None:
        pass

    def parse_nmap_output(self, raw_output: str) -> List[Tuple[int, str]]:
        """
        从 nmap 文本输出中提取开放端口与服务名。
        这里实现一个非常简化的解析逻辑，适配 nmap -F 的典型输出。
        """
        services: List[Tuple[int, str]] = []

        for line in raw_output.splitlines():
            line = line.strip()
            # 典型行示例: "22/tcp open  ssh"
            if not line or "/" not in line:
                continue
            if "tcp" not in line and "udp" not in line:
                continue
            parts = line.split()
            if len(parts) < 3:
                continue
            port_proto = parts[0]  # 22/tcp
            state = parts[1]       # open/filtered 等
            service = parts[2]     # ssh/http 等

            if "open" not in state:
                continue

            try:
                port_str, _ = port_proto.split("/", 1)
                port = int(port_str)
            except ValueError:
                continue

            services.append((port, service.lower()))

        return services

    def _is_web_open(self, services: List[Tuple[int, str]]) -> tuple[bool, bool]:
        """
        判断是否开放 Web 服务：
        - port 80 视为 HTTP
        - port 443 视为 HTTPS
        返回 (http_open, https_open)
        """
        http_open = any(port == 80 for port, _ in services)
        https_open = any(port == 443 for port, _ in services)
        return http_open, https_open

    def _should_test_sqli(self, url: str) -> bool:
        u = url.lower()
        return any(kw in u for kw in ["id=", "login", "user", "profile", ".php?"])

    def _should_test_xss(self, url: str) -> bool:
        u = url.lower()
        return any(kw in u for kw in ["q=", "search", "callback", "api/", ".json"])

    def _analyze_url_for_vulns(self, url: str) -> List[str]:
        """
        基于 URL 规则分析，决定可能需要启用的子 AI。
        返回如 ["sqli", "xss"]。
        """
        agents: List[str] = []
        if self._should_test_sqli(url):
            agents.append("sqli")
        if self._should_test_xss(url):
            agents.append("xss")
        # 去重并保持顺序
        return list(dict.fromkeys(agents))

    def run(self, target: str) -> str:
        """
        CLI 兼容：将 run_full 的 reports 简单拼接为字符串返回（UI 仍建议使用 run_full）。
        """
        result = self.run_full(target)
        reports = result.get("reports", [])
        if isinstance(reports, list) and reports:
            # CLI 输出可读性：多份报告用分隔线拼接
            if len(reports) == 1:
                return str(reports[0])
            return "\n\n" + ("=" * 80 + "\n\n").join(str(r) for r in reports)
        return ""

    def run_full(self, target: str) -> Dict[str, object]:
        """
        主调度器完整流程：
        1) nmap -F 快速扫描
        2) 判断 80/443 是否开放 Web 服务；无 Web 则直接返回 reports=[]
        3) 构造 base_url（优先 https，否则 http）
        4) Dirsearch 扫描，筛选 200/403 URL
        5) 对 URL 做规则分析并分发给 SQLiAgent/XSSAgent
        6) 收集子 AI 成功验证的标准报告字符串，返回 reports 列表
        """
        # 允许传入 URL / host / IP：对 nmap 只使用 hostname
        target = target.strip()
        parsed = urlparse(target)
        host = parsed.hostname if parsed.scheme in {"http", "https"} else target
        if not host:
            return {"target": target, "discovered_urls": [], "reports": []}

        logger.info(f"[orchestrator] Starting orchestration workflow for: {host}")

        raw_nmap_output = run_nmap_fast_scan(host)
        services = self.parse_nmap_output(raw_nmap_output)
        logger.info(f"[orchestrator] Found {len(services)} open services for {host}")

        http_open, https_open = self._is_web_open(services)
        if not http_open and not https_open:
            logger.info("[orchestrator] No web service (80/443) detected; skipping dirsearch and subagents")
            return {"target": host, "discovered_urls": [], "reports": []}

        base_url = f"https://{host}" if https_open else f"http://{host}"
        logger.info(f"[orchestrator] Base URL selected: {base_url}")

        # Dirsearch 扫描
        dirsearch = DirsearchAgent()
        discovered_urls = dirsearch.run(base_url)
        # 强制只处理 200/403，防御性过滤
        discovered_urls = [
            item
            for item in discovered_urls
            if isinstance(item, dict)
            and item.get("status") in (200, 403)
            and isinstance(item.get("url"), str)
        ]
        logger.info(f"[orchestrator] Dirsearch returned {len(discovered_urls)} URLs (200/403)")

        reports: List[str] = []
        # 去重控制：每个 URL 每种类型只测一次
        tested: set[tuple[str, str]] = set()

        for item in discovered_urls:
            url = str(item["url"])
            possible = self._analyze_url_for_vulns(url)
            if not possible:
                continue

            if "sqli" in possible and (url, "sqli") not in tested:
                tested.add((url, "sqli"))
                try:
                    sqli = SQLiAgent()
                    res = sqli.run({"url": url})
                    if getattr(res, "success", False) and getattr(res, "report", None):
                        reports.append(str(res.report))
                except Exception as exc:  # noqa: BLE001
                    logger.error(f"[orchestrator] SQLiAgent failed for {url}: {exc}")

            if "xss" in possible and (url, "xss") not in tested:
                tested.add((url, "xss"))
                try:
                    xss = XSSAgent()
                    res = xss.run({"url": url})
                    if getattr(res, "success", False) and getattr(res, "report", None):
                        reports.append(str(res.report))
                except Exception as exc:  # noqa: BLE001
                    logger.error(f"[orchestrator] XSSAgent failed for {url}: {exc}")

        return {"target": host, "discovered_urls": discovered_urls, "reports": reports}

