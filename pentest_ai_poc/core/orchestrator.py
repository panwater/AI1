from __future__ import annotations

from typing import Any, Dict, List, Tuple
from urllib.parse import urlparse

from core.logger import logger
from core.web_orchestrator import WebOrchestrator
from plugins.nmap_scanner import run_nmap_fast_scan


class Orchestrator:
    """
    网络层扫描协调器：
    1. nmap 快速扫描
    2. 解析开放端口和服务
    3. 检测 Web 服务（80/443）
    4. 若发现 Web 服务，委托 WebOrchestrator 执行 Web 渗透测试
    注意：不再生成 AI 风险评估报告，不再检索 CVE。
    只有子 AI（如 SQLiAgent）成功验证漏洞后才生成报告。
    """

    def __init__(self) -> None:
        pass

    def parse_nmap_output(self, raw_output: str) -> List[Tuple[int, str]]:
        """
        从 nmap 文本输出中提取开放端口与服务名。
        这里实现一个非常简化的解析逻辑，适配 nmap -F 的典型输出。
        """
        services: List[Tuple[int, str]] = []

        for line in raw_output.splitlines():
            line = line.strip()
            # 典型行示例: "22/tcp open  ssh"
            if not line or "/" not in line:
                continue
            if "tcp" not in line and "udp" not in line:
                continue
            parts = line.split()
            if len(parts) < 3:
                continue
            port_proto = parts[0]  # 22/tcp
            state = parts[1]       # open/filtered 等
            service = parts[2]     # ssh/http 等

            if "open" not in state:
                continue

            try:
                port_str, _ = port_proto.split("/", 1)
                port = int(port_str)
            except ValueError:
                continue

            services.append((port, service.lower()))

        return services

    def _is_web_open(self, services: List[Tuple[int, str]]) -> tuple[bool, bool]:
        """
        判断是否开放 Web 服务：
        - port 80 视为 HTTP
        - port 443 视为 HTTPS
        返回 (http_open, https_open)
        """
        http_open = any(port == 80 for port, _ in services)
        https_open = any(port == 443 for port, _ in services)
        return http_open, https_open

    def run(self, target: str) -> str:
        """
        CLI 兼容：将 run_full 的 reports 简单拼接为字符串返回（UI 仍建议使用 run_full）。
        """
        result = self.run_full(target)
        reports = result.get("reports", [])
        if isinstance(reports, list) and reports:
            # CLI 输出可读性：多份报告用分隔线拼接
            if len(reports) == 1:
                return str(reports[0])
            return "\n\n" + ("=" * 80 + "\n\n").join(str(r) for r in reports)
        return ""

    def run_full(self, target: str) -> Dict[str, object]:
        """
        主调度器完整流程：
        1) nmap -F 快速扫描
        2) 判断 80/443 是否开放 Web 服务；无 Web 则直接返回 reports=[]
        3) 若发现 Web 服务，构造干净的 base_url（仅协议 + host）
        4) 委托 WebOrchestrator 执行 Web 渗透测试（Dirsearch + 子 Agent）
        5) 从 WebOrchestrator 返回结果中提取 reports 和 discovered_urls
        """
        # 允许传入 URL / host / IP：对 nmap 只使用 hostname
        target = target.strip()
        parsed = urlparse(target)
        host = parsed.hostname if parsed.scheme in {"http", "https"} else target
        if not host:
            return {"target": target, "discovered_urls": [], "reports": []}

        logger.info(f"[orchestrator] Starting orchestration workflow for: {host}")

        # Step 1: Nmap 快速扫描
        raw_nmap_output = run_nmap_fast_scan(host)
        services = self.parse_nmap_output(raw_nmap_output)
        logger.info(f"[orchestrator] Found {len(services)} open services for {host}")

        # Step 2: 检测 Web 服务
        http_open, https_open = self._is_web_open(services)
        if not http_open and not https_open:
            logger.info(
                "[orchestrator] No web service (80/443) detected; skipping web penetration test"
            )
            return {"target": host, "discovered_urls": [], "reports": []}

        # Step 3: 构造干净的 base URL（仅协议 + host，丢弃 path/query）
        base_url = f"https://{host}" if https_open else f"http://{host}"
        logger.info(f"[orchestrator] Web service detected, delegating to WebOrchestrator: {base_url}")

        # Step 4: 委托 WebOrchestrator 执行 Web 渗透测试
        try:
            web_orch = WebOrchestrator()
            web_result = web_orch.run_full(base_url)

            # Step 5: 提取结果，保持接口兼容性
            discovered_urls = web_result.get("discovered_urls", [])
            # 从 report 字段提取报告列表（如果是字符串，尝试分割；如果是列表，直接使用）
            report_str = web_result.get("report", "")
            if isinstance(report_str, str) and report_str:
                # 如果包含分隔符，分割成列表；否则作为单个报告
                if "=" * 80 in report_str:
                    reports = [
                        r.strip()
                        for r in report_str.split("=" * 80)
                        if r.strip() and not r.strip().startswith("本次扫描未发现")
                    ]
                else:
                    reports = [report_str] if report_str else []
            else:
                reports = []

            logger.info(
                f"[orchestrator] WebOrchestrator completed: {len(discovered_urls)} URLs, {len(reports)} vulnerabilities"
            )

            return {
                "target": host,
                "discovered_urls": discovered_urls,
                "reports": reports,
            }
        except Exception as exc:  # noqa: BLE001
            logger.error(f"[orchestrator] WebOrchestrator failed: {exc}")
            return {"target": host, "discovered_urls": [], "reports": []}

