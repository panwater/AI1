import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple

from core.agent import AIAgent
from core.logger import logger
from knowledge.rag import load_cve_kb, retrieve_cves_for_services
from plugins.nmap_scanner import run_nmap_fast_scan


class Orchestrator:
    """
    协调：
    1. nmap 快速扫描
    2. 简单解析扫描结果
    3. 基于服务关键词做 RAG 检索
    4. 调用 Ollama AI 生成风险评估报告
    """

    def __init__(self) -> None:
        self.agent = AIAgent()
        # 报告保存目录
        self.reports_dir = Path(__file__).resolve().parent.parent / "data" / "reports"
        self.reports_dir.mkdir(parents=True, exist_ok=True)

    def parse_nmap_output(self, raw_output: str) -> List[Tuple[int, str]]:
        """
        从 nmap 文本输出中提取开放端口与服务名。
        这里实现一个非常简化的解析逻辑，适配 nmap -F 的典型输出。
        """
        services: List[Tuple[int, str]] = []

        for line in raw_output.splitlines():
            line = line.strip()
            # 典型行示例: "22/tcp open  ssh"
            if not line or "/" not in line:
                continue
            if "tcp" not in line and "udp" not in line:
                continue
            parts = line.split()
            if len(parts) < 3:
                continue
            port_proto = parts[0]  # 22/tcp
            state = parts[1]       # open/filtered 等
            service = parts[2]     # ssh/http 等

            if "open" not in state:
                continue

            try:
                port_str, _ = port_proto.split("/", 1)
                port = int(port_str)
            except ValueError:
                continue

            services.append((port, service.lower()))

        return services

    def build_prompt(
        self,
        target: str,
        services: List[Tuple[int, str]],
        cve_matches: Dict[str, List[Dict[str, str]]],
    ) -> str:
        """
        将扫描结果 + CVE 信息拼接为发送给 AI 的 prompt。
        """
        lines: List[str] = []
        lines.append("你是一个资深渗透测试工程师，请基于以下信息对目标进行初步风险评估。")
        lines.append("")
        lines.append(f"目标: {target}")
        lines.append("")
        lines.append("一、nmap 快速扫描结果 (开放端口/服务)：")

        if not services:
            lines.append("  - 未发现开放端口（或解析失败）")
        else:
            for port, service in services:
                lines.append(f"  - 端口 {port} / 服务 {service}")

        lines.append("")
        lines.append("二、基于服务关键词检索到的示例 CVE：")
        if not cve_matches:
            lines.append("  - 未从知识库中检索到相关 CVE")
        else:
            for service, items in cve_matches.items():
                lines.append(f"  - 服务 {service}:")
                for item in items:
                    lines.append(
                        f"    * {item.get('cve_id','未知CVE')} - {item.get('desc','')}"
                    )

        lines.append("")
        lines.append("请你：")
        lines.append("1. 总结可能的风险点；")
        lines.append("2. 指出与上述 CVE 可能相关的攻击面（仅作为示例，不假定真实存在漏洞）；")
        lines.append("3. 给出后续人工渗透测试/加固建议。")
        lines.append("请使用简体中文输出一段结构化报告。")

        return "\n".join(lines)

    def run(self, target: str) -> str:
        """
        保持 CLI 兼容，直接返回 AI 报告。
        """
        result = self.run_full(target)
        return result.get("report", "")

    def _save_report(self, target: str, report: str, raw_nmap_output: str, services: List[Tuple[int, str]], cve_matches: Dict[str, List[Dict[str, str]]]) -> str:
        """
        保存报告到 data/reports/{timestamp}_report.md
        返回文件名（不含路径）
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{timestamp}_report.md"
        filepath = self.reports_dir / filename

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(f"# 渗透测试报告\n\n")
            f.write(f"**目标**: {target}\n\n")
            f.write(f"**生成时间**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write(f"---\n\n")
            f.write(f"## 扫描结果\n\n")
            f.write(f"### 开放端口/服务\n\n")
            if services:
                for port, service in services:
                    f.write(f"- 端口 {port} / 服务 {service}\n")
            else:
                f.write("- 未发现开放端口\n")
            f.write(f"\n### CVE 匹配结果\n\n")
            if cve_matches:
                for service, items in cve_matches.items():
                    f.write(f"#### {service}\n")
                    for item in items:
                        f.write(f"- **{item.get('cve_id', '未知CVE')}**: {item.get('desc', '')}\n")
            else:
                f.write("- 未匹配到相关 CVE\n")
            f.write(f"\n---\n\n")
            f.write(f"## nmap 原始输出\n\n")
            f.write(f"```\n{raw_nmap_output}\n```\n\n")
            f.write(f"---\n\n")
            f.write(f"## AI 风险评估报告\n\n")
            f.write(f"{report}\n")

        logger.info(f"[orchestrator] Report saved to {filepath}")
        return filename

    def run_full(self, target: str) -> Dict[str, object]:
        """
        整体执行流程（返回详细结果，便于 Web 展示）：
        1. 调用 nmap -F target
        2. 解析开放端口和服务
        3. RAG 检索 CVE
        4. 调用 Ollama qwen3-coder:30b 生成风险评估报告
        5. 保存报告到文件
        """
        logger.info(f"[orchestrator] Starting full scan workflow for target: {target}")
        raw_nmap_output = run_nmap_fast_scan(target)
        services = self.parse_nmap_output(raw_nmap_output)
        logger.info(f"[orchestrator] Found {len(services)} open services")

        cve_kb = load_cve_kb()
        cve_matches = retrieve_cves_for_services(services, cve_kb)

        prompt = self.build_prompt(target, services, cve_matches)
        report = self.agent.generate_report(prompt)

        # 保存报告
        report_filename = self._save_report(target, report, raw_nmap_output, services, cve_matches)

        return {
            "target": target,
            "report": report,
            "raw_nmap_output": raw_nmap_output,
            "services": services,
            "cve_matches": cve_matches,
            "prompt": prompt,
            "report_filename": report_filename,
        }

