from __future__ import annotations

from dataclasses import asdict, dataclass
from typing import Any, Dict, List

from core.agents import AgentResult
from core.logger import logger
from plugins.fingerprinter import FingerprintResult, fingerprint_url
from subagents.sqli_agent import SQLiAgent
from subagents.xss_agent import XSSAgent

@dataclass
class MultiAgentResult:
    url: str
    target: str
    fingerprint: FingerprintResult
    agent_results: List[AgentResult]
    reports: List[str]  # 标准格式报告列表（每个成功发现的漏洞一份报告）
    report_filename: str


class WebOrchestrator:
    """
    多智能体 Web 渗透测试 Orchestrator：
    1. 指纹识别（指纹 + 表单等特征）
    2. 决策需要启用的子 AI（SQLi / XSS 等）
    3. 顺序调用子 AI（避免高并发 DoS）
    4. 汇总子 AI 生成的报告
    注意：不再调用 LLM 生成报告，只有子 AI 成功验证漏洞后才生成报告。
    """

    def __init__(self) -> None:
        pass

    def _select_agents(self, fp: FingerprintResult) -> List[Any]:
        """
        根据指纹结果决定启用哪些子 AI。
        """
        tech = (fp.tech_stack or "").lower()
        agents: List[Any] = []

        # 发现表单 + PHP/MySQL 之类技术栈 → SQLi 高优先级
        if fp.has_form and ("php" in tech or "mysql" in tech or tech == "unknown"):
            agents.append(SQLiAgent())

        # 存在表单则可以尝试 XSS
        if fp.has_form:
            agents.append(XSSAgent())

        return agents

    def _extract_reports_from_agents(
        self,
        agent_results: List[AgentResult],
    ) -> List[str]:
        """
        从子 AI 结果中提取已生成的报告。
        返回报告列表（每个成功发现的漏洞一份报告）。
        """
        reports: List[str] = []
        for agent_result in agent_results:
            if agent_result.success and agent_result.vuln and agent_result.report:
                reports.append(agent_result.report)
                logger.info(
                    f"[web_orchestrator] Extracted report from {agent_result.name} for {agent_result.vuln}"
                )
        return reports

    def run_full(self, url: str) -> Dict[str, Any]:
        """
        多智能体 Web 渗透测试完整流程。
        返回结构化结果，供 Web UI 展示。
        """
        logger.info(f"[web_orchestrator] Starting multi-agent workflow for URL: {url}")

        fp = fingerprint_url(url)

        # 从 URL 提取“目标”显示用
        target = url
        for prefix in ("http://", "https://"):
            if target.startswith(prefix):
                target = target[len(prefix) :]
                break

        agents = self._select_agents(fp)
        agent_results: List[AgentResult] = []

        for agent in agents:
            try:
                res = agent.run({"url": url, "fingerprint": asdict(fp)})
            except Exception as exc:  # noqa: BLE001
                logger.error(f"[web_orchestrator] Agent {agent.name} failed: {exc}")
                res = AgentResult(
                    name=agent.name,
                    success=False,
                    error=str(exc),
                )
            agent_results.append(res)

        # 从子 AI 结果中提取已生成的报告（报告已在子 AI 中生成并保存）
        reports = self._extract_reports_from_agents(agent_results)

        # 生成汇总报告文本（用于 Web UI 显示）
        # 如果有多个报告，拼接；如果只有一个，直接使用；如果没有，显示提示
        if reports:
            if len(reports) == 1:
                ai_report = reports[0]
            else:
                ai_report = "\n\n" + "=" * 80 + "\n\n".join(reports)
        else:
            ai_report = "本次扫描未发现漏洞。所有子 AI 均未确认到明确的漏洞。"

        # 获取第一个报告文件名（如果有多个，使用第一个）
        report_filename = ""
        for agent_result in agent_results:
            if agent_result.report_filename:
                report_filename = agent_result.report_filename
                break

        enabled_agents = [a.name for a in agents]

        # 兼容现有 Web UI 字段命名
        return {
            "url": url,
            "target": target,
            "tech_stack": fp.tech_stack,
            "has_form": fp.has_form,
            "enabled_agents": enabled_agents,
            "agent_results": [asdict(r) for r in agent_results],
            "report": ai_report,  # 标准格式报告（或多个报告的拼接）
            "report_filename": report_filename,
            # 兼容历史字段（对 Web 流程可为空）
            "raw_nmap_output": "",
            "services": [],
            "cve_matches": {},
        }

