from __future__ import annotations

from dataclasses import asdict, dataclass
from typing import Any, Dict, List

from core.agents import AgentResult
from core.logger import logger
from plugins.fingerprinter import FingerprintResult, fingerprint_url
from subagents.dirsearch_agent import DirsearchAgent
from subagents.sqli_agent import SQLiAgent
from subagents.xss_agent import XSSAgent

@dataclass
class MultiAgentResult:
    url: str
    target: str
    fingerprint: FingerprintResult
    agent_results: List[AgentResult]
    reports: List[str]  # 标准格式报告列表（每个成功发现的漏洞一份报告）
    report_filename: str


class WebOrchestrator:
    """
    多智能体 Web 渗透测试 Orchestrator：
    1. 启动 Dirsearch 扫描发现路径
    2. 分析每个 URL 的漏洞可能性（基于规则匹配）
    3. 智能分发任务给对应的功能子 AI（SQLi / XSS 等）
    4. 顺序调用子 AI（避免高并发 DoS）
    5. 汇总子 AI 生成的报告
    注意：不再调用 LLM 生成报告，只有子 AI 成功验证漏洞后才生成报告。
    """

    def __init__(self) -> None:
        pass

    def _analyze_url_for_vulns(self, url: str) -> List[str]:
        """
        基于 URL 路径关键词判断可能漏洞类型。

        参数:
            url: 目标 URL（如 "http://target.com/login.php?id=1"）

        返回:
            List[str]: 可能的漏洞类型列表，如 ["sqli", "xss"]
        """
        url_lower = url.lower()
        possible_agents: List[str] = []

        # SQL 注入可能性判断
        sql_indicators = [
            "login",
            "user",
            "id=",
            "admin",
            "account",
            "profile",
            "search",
            "query=",
            "select",
            ".php",
            ".asp",
            ".aspx",
        ]
        if any(indicator in url_lower for indicator in sql_indicators):
            possible_agents.append("sqli")

        # XSS 可能性判断
        xss_indicators = [
            "search",
            "q=",
            "callback=",
            "comment",
            "message",
            "input",
            "form",
            ".html",
            ".htm",
        ]
        if any(indicator in url_lower for indicator in xss_indicators):
            possible_agents.append("xss")

        # API 相关（可能同时存在 XSS 和 IDOR）
        api_indicators = ["api", ".json", "/v1/", "/v2/", "/api/"]
        if any(indicator in url_lower for indicator in api_indicators):
            possible_agents.append("xss")
            # 注意：IDOR 需要更复杂的逻辑判断，这里暂不实现

        # 文件上传可能性判断
        upload_indicators = ["upload", "file=", "attach"]
        if any(indicator in url_lower for indicator in upload_indicators):
            # 文件上传漏洞检测需要专门的 Agent，这里暂不实现
            pass

        # 去重
        return list(dict.fromkeys(possible_agents))

    def _select_agents(self, fp: FingerprintResult) -> List[Any]:
        """
        根据指纹结果决定启用哪些子 AI。
        """
        tech = (fp.tech_stack or "").lower()
        agents: List[Any] = []

        # 发现表单 + PHP/MySQL 之类技术栈 → SQLi 高优先级
        if fp.has_form and ("php" in tech or "mysql" in tech or tech == "unknown"):
            agents.append(SQLiAgent())

        # 存在表单则可以尝试 XSS
        if fp.has_form:
            agents.append(XSSAgent())

        return agents

    def _extract_reports_from_agents(
        self,
        agent_results: List[AgentResult],
    ) -> List[str]:
        """
        从子 AI 结果中提取已生成的报告。
        返回报告列表（每个成功发现的漏洞一份报告）。
        """
        reports: List[str] = []
        for agent_result in agent_results:
            if agent_result.success and agent_result.vuln and agent_result.report:
                reports.append(agent_result.report)
                logger.info(
                    f"[web_orchestrator] Extracted report from {agent_result.name} for {agent_result.vuln}"
                )
        return reports

    def run_full(self, target: str) -> Dict[str, Any]:
        """
        多智能体 Web 渗透测试完整流程（支持 Dirsearch 扫描和智能任务分发）。

        参数:
            target: 目标（可以是 IP、域名或完整 URL）

        返回:
            结构化结果，供 Web UI 展示
        """
        logger.info(f"[web_orchestrator] Starting multi-agent workflow for target: {target}")

        # Step 1: 构造 base URL（假设 HTTP）
        base_url = target
        if not target.startswith(("http://", "https://")):
            base_url = f"http://{target}"

        # Step 2: 启动 Dirsearch 扫描
        dirsearch_agent = DirsearchAgent()
        discovered_urls = dirsearch_agent.run(base_url)

        logger.info(
            f"[web_orchestrator] Dirsearch found {len(discovered_urls)} interesting URLs"
        )

        # Step 3: 对每个 200/403 URL 分析并分发任务
        all_reports: List[str] = []
        all_agent_results: List[AgentResult] = []
        all_report_filenames: List[str] = []

        for item in discovered_urls:
            url = item["url"]
            status = item["status"]

            logger.info(
                f"[web_orchestrator] Analyzing URL: {url} (status: {status})"
            )

            # 分析 URL 可能的漏洞类型
            possible_agents = self._analyze_url_for_vulns(url)

            if not possible_agents:
                logger.info(
                    f"[web_orchestrator] No obvious vulnerability indicators for {url}"
                )
                continue

            logger.info(
                f"[web_orchestrator] URL {url} may have: {', '.join(possible_agents)}"
            )

            # Step 4: 调用对应子 AI
            if "sqli" in possible_agents:
                try:
                    sqli = SQLiAgent()
                    result = sqli.run({"url": url})
                    all_agent_results.append(result)

                    if result.success and result.vuln and result.report:
                        all_reports.append(result.report)
                        if result.report_filename:
                            all_report_filenames.append(result.report_filename)
                        logger.info(
                            f"[web_orchestrator] SQLiAgent found vulnerability in {url}"
                        )
                except Exception as exc:
                    logger.error(f"[web_orchestrator] SQLiAgent failed for {url}: {exc}")

            if "xss" in possible_agents:
                try:
                    xss = XSSAgent()
                    result = xss.run({"url": url})
                    all_agent_results.append(result)

                    if result.success and result.vuln and result.report:
                        all_reports.append(result.report)
                        if result.report_filename:
                            all_report_filenames.append(result.report_filename)
                        logger.info(
                            f"[web_orchestrator] XSSAgent found vulnerability in {url}"
                        )
                except Exception as exc:
                    logger.error(f"[web_orchestrator] XSSAgent failed for {url}: {exc}")

        # Step 5: 生成汇总报告文本（用于 Web UI 显示）
        # 每个漏洞一份独立报告，用分隔符分隔
        if all_reports:
            if len(all_reports) == 1:
                ai_report = all_reports[0]
            else:
                ai_report = "\n\n" + "=" * 80 + "\n\n".join(all_reports)
        else:
            ai_report = "本次扫描未发现漏洞。所有子 AI 均未确认到明确的漏洞。"

        # 获取第一个报告文件名（如果有多个，使用第一个）
        report_filename = all_report_filenames[0] if all_report_filenames else ""

        # 从 URL 提取"目标"显示用
        display_target = target
        for prefix in ("http://", "https://"):
            if display_target.startswith(prefix):
                display_target = display_target[len(prefix) :]
                break

        # 执行指纹识别（用于显示技术栈信息）
        fp = fingerprint_url(base_url)

        # 兼容现有 Web UI 字段命名
        return {
            "url": base_url,
            "target": display_target,
            "tech_stack": fp.tech_stack,
            "has_form": fp.has_form,
            "enabled_agents": ["Dirsearch Scanner", "SQLi Tester", "XSS Tester"],
            "agent_results": [asdict(r) for r in all_agent_results],
            "report": ai_report,  # 标准格式报告（或多个报告的拼接）
            "report_filename": report_filename,
            "discovered_urls": discovered_urls,  # 新增：Dirsearch 发现的 URL 列表
            # 兼容历史字段（对 Web 流程可为空）
            "raw_nmap_output": "",
            "services": [],
            "cve_matches": {},
        }

