import subprocess
from typing import List
import re
from core.logger import logger

# 修改后的正则表达式
# 1. IPv4 部分保持不变
# 2. 域名部分：
#    - 允许子域包含字母、数字、连字符 (支持 UUID 格式)
#    - 支持多级子域
#    - 顶级域名 (TLD) 允许 2 到 63 个字符 (涵盖所有现有及未来可能的 TLD)
_TARGET_PATTERN = re.compile(
    r"^(?:"
    r"(?:\d{1,3}\.){3}\d{1,3}"  # IPv4
    r"|"
    r"(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+"  # 子域部分，支持连字符，但不能以连字符开头或结尾
    r"[a-zA-Z]{2,63}"  # 顶级域名
    r")$"
)

def is_safe_target(target: str) -> bool:
    """
    仅允许简单的域名或 IPv4 地址，拒绝包含危险字符。
    支持 CTF 常见的 UUID 子域格式 (如 xxxxxx-xxxx-xxxx.node5.buuoj.cn)
    """
    target = target.strip()
    if not target:
        return False
    
    # 定义危险字符列表
    dangerous_chars = [";", "|", "&", ">", "<", "$", "`", "(", ")", "{", "}", "[", "]", "\\", "\n", "\r", " "]
    
    # 检查是否包含危险字符 (包括空格，防止参数注入)
    if any(ch in target for ch in dangerous_chars):
        return False

    # 额外检查：防止以连字符开头或结尾的片段（虽然正则已尽量限制，但双重保险）
    # 注意：这里不强制禁止，因为正则已经处理了大部分情况，主要依赖正则匹配
    
    return bool(_TARGET_PATTERN.match(target))

def run_nmap_fast_scan(target: str) -> str:
    """
    安全方式调用 nmap -F <target>，返回文本输出。
    """
    if not is_safe_target(target):
        raise ValueError(f"非法 target: {target}")

    # 使用列表形式传递参数，避免 shell 注入
    cmd: List[str] = ["nmap", "-F", target]
    
    try:
        completed = subprocess.run(
            cmd,
            check=False,
            capture_output=True,
            text=True,
            timeout=60  # 增加超时限制，防止挂起
        )
    except FileNotFoundError:
        return "[ERROR] nmap 未安装或未在 PATH 中。"
    except subprocess.TimeoutExpired:
        return "[ERROR] nmap 执行超时。"

    if completed.returncode != 0:
        # 注意：stderr 可能包含敏感信息，生产环境中建议过滤或日志记录而不是直接返回
        return f"[ERROR] nmap 执行失败，返回码 {completed.returncode}。"

    return completed.stdout