from __future__ import annotations

import os
import re
import subprocess
import json
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse
import requests

from core.agents import AgentResult, BaseAgent
from core.logger import logger


class ParameterFuzzer:
    """
    å‚æ•°æ¨¡ç³Šæµ‹è¯•å™¨ï¼Œä½¿ç”¨ ffuf å·¥å…·å¯¹ URL è¿›è¡Œå‚æ•°çˆ†ç ´ã€‚
    æ ¸å¿ƒç­–ç•¥ï¼š
    1. èŽ·å–åŸºå‡†çº¿é•¿åº¦ (Baseline Size)ã€‚
    2. è¿è¡Œ ffuf èŽ·å–å…¨é‡ç»“æžœ (ç§»é™¤ -mc è¿‡æ»¤)ï¼Œè¾“å‡ºåˆ° test.txtã€‚
    3. Python è§£æž test.txtï¼Œä»…ä¿ç•™å“åº”é•¿åº¦ != åŸºå‡†é•¿åº¦çš„å‚æ•°ã€‚
    """

    name = "Parameter Fuzzer"

    def __init__(self, wordlist_rel_path: str | None = None, match_codes: str | None = "200,301,302"):
        # åŸºç¡€ç›®å½• (æ ¹æ®ä½ çš„å®žé™…è·¯å¾„é…ç½®)
        self.ffuf_base_dir = r"D:\web\ä¿¡æ¯æ”¶é›†\JS_Extender\ffuf_2.0.0_windows_amd64"
        
        # ç»å¯¹è·¯å¾„çš„å¯æ‰§è¡Œæ–‡ä»¶
        self.ffuf_exe_abs = os.path.join(self.ffuf_base_dir, "ffuf.exe")
        
        if wordlist_rel_path is None:
            wordlist_rel_path = "1.txt"
        self.wordlist_rel_path = wordlist_rel_path
        
        self.match_codes = match_codes

    def _get_baseline_size(self, url: str) -> int:
        """
        èŽ·å–ä¸å¸¦ fuzz å‚æ•°çš„åŽŸå§‹ URL å“åº”å¤§å°ï¼Œä½œä¸ºè¿‡æ»¤åŸºå‡†ã€‚
        è¿”å›ž: å“åº”å†…å®¹é•¿åº¦ (int)ï¼Œå¤±è´¥è¿”å›ž -1ã€‚
        """
        try:
            # ç§»é™¤ URL ä¸­å¯èƒ½å­˜åœ¨çš„ ? åŠå…¶åŽçš„å†…å®¹ï¼Œå¾—åˆ°åŸºç¡€ URL
            clean_url = url.split('?')[0]
            # æ·»åŠ ä¸€ä¸ªéšæœºå‚æ•°é˜²æ­¢ CDN æˆ–æµè§ˆå™¨ç¼“å­˜å¹²æ‰°åŸºå‡†çº¿
            check_url = f"{clean_url}?_baseline_check={os.urandom(4).hex()}"
            
            response = requests.get(check_url, timeout=10)
            baseline_size = len(response.content)
            
            logger.info(f"[parameter_fuzzer] Baseline response size for {clean_url} is {baseline_size} bytes.")
            return baseline_size
        except requests.RequestException as e:
            logger.error(f"[parameter_fuzzer] Failed to get baseline size for {url}: {e}")
            return -1

    def _is_valid_url_for_fuzzing(self, url: str) -> bool:
        """ç®€å•çš„ URL æœ‰æ•ˆæ€§æ£€æŸ¥"""
        url_lower = url.lower()
        try:
            parsed = urlparse(url)
        except Exception:
            parsed = None

        skip_patterns = [
            ".htaccess", ".css", ".js", ".jpg", ".png", ".gif", ".ico",
            "/cgi-bin/", "/server-status", "/server-info", "::$DATA",
            "html",
        ]
        if any(pattern in url_lower for pattern in skip_patterns):
            return False

        if parsed is not None:
            path = parsed.path or "/"
            if path == "/" and "?" not in url:
                return True

        dynamic_extensions = [".php", ".asp", ".aspx", ".jsp", ".do", ".action"]
        if any(url_lower.endswith(ext) for ext in dynamic_extensions):
            return True

        if not url.endswith("/") and "?" not in url:
            return True

        return False

    def fuzz_parameters(self, url: str) -> List[str]:
        if not isinstance(url, str) or not url.strip():
            logger.error("[parameter_fuzzer] Invalid URL")
            return []

        url = url.strip()

        if not self._is_valid_url_for_fuzzing(url):
            logger.debug(f"[parameter_fuzzer] Skipping parameter fuzzing for {url} (not suitable)")
            return []

        # 1. é¢„å…ˆæ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not os.path.isdir(self.ffuf_base_dir):
            logger.error(f"[parameter_fuzzer] Base directory not found: {self.ffuf_base_dir}")
            return []
        
        if not os.path.isfile(self.ffuf_exe_abs):
            logger.error(f"[parameter_fuzzer] ffuf.exe not found at: {self.ffuf_exe_abs}")
            return []

        # æž„å»ºå­—å…¸çš„ç»å¯¹è·¯å¾„ (å…³é”®ä¿®å¤ï¼šffuf -w éœ€è¦ç»å¯¹è·¯å¾„)
        wordlist_abs = os.path.join(self.ffuf_base_dir, self.wordlist_rel_path)
        if not os.path.isfile(wordlist_abs):
            logger.error(f"[parameter_fuzzer] Wordlist not found at: {wordlist_abs}")
            return []

        logger.info(f"[parameter_fuzzer] Starting FULL parameter fuzzing for: {url}")
        logger.info(f"[parameter_fuzzer] Working directory: {self.ffuf_base_dir}")
        logger.warning("[parameter_fuzzer] All raw ffuf outputs will be saved to 'test.txt' in the ffuf directory.")

        # 2. èŽ·å–åŸºå‡†å“åº”å¤§å° (å…³é”®æ­¥éª¤)
        baseline_size = self._get_baseline_size(url)

        # æž„é€ æµ‹è¯• URL (æ³¨æ„ï¼šè¿™é‡Œä¸éœ€è¦é¢å¤–åŠ åŒå¼•å·ï¼Œsubprocess åˆ—è¡¨ä¼šè‡ªåŠ¨å¤„ç†)
        test_url = f'{url}?FUZZ=1&submit=1'

        # --- å®šä¹‰è¾“å‡ºæ–‡ä»¶ ---
        output_file_name = "test.txt"
        temp_output_file = os.path.join(self.ffuf_base_dir, output_file_name)
        
        # --- æž„å»ºå‘½ä»¤ ---
        # å…³é”®ç‚¹ï¼š
        # 1. -w ä½¿ç”¨ç»å¯¹è·¯å¾„ wordlist_abs
        # 2. ç§»é™¤ -mc (ä¸è¿‡æ»¤çŠ¶æ€ç ï¼ŒèŽ·å–å…¨é‡)
        # 3. ç§»é™¤ -se (é‡åˆ°é”™è¯¯ä¸åœæ­¢)
        # 4. -o è¾“å‡ºåˆ° test.txt
        cmd = [
            self.ffuf_exe_abs,
            "-w", wordlist_abs,       # ðŸ‘ˆ ä½¿ç”¨ç»å¯¹è·¯å¾„
            "-u", test_url,
            "-json",                  # JSON æ ¼å¼è¾“å‡º
            "-o", output_file_name,   # è¾“å‡ºåˆ°ç›¸å¯¹è·¯å¾„ (ç›¸å¯¹äºŽ cwd)
            "-c",                    # å½©è‰²è¾“å‡º (ä¸å½±å“æ–‡ä»¶)
            "-t", "40",              # çº¿ç¨‹æ•°
            # "-mc", self.match_codes, # ðŸ‘ˆ å·²ç§»é™¤ï¼šæˆ‘ä»¬è¦æ‰€æœ‰ç»“æžœ
            # "-se",                 # ðŸ‘ˆ å·²ç§»é™¤ï¼šé‡åˆ°é”™è¯¯ä¸è¦åœæ­¢
        ]

        logger.debug(f"[parameter_fuzzer] Executing command: {' '.join(cmd)}")

        try:
            startupinfo = None
            if os.name == 'nt':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW

            # 3. æ‰§è¡Œå‘½ä»¤
            completed = subprocess.run(
                cmd,
                cwd=self.ffuf_base_dir,  # åœ¨æ­¤ç›®å½•ä¸‹è¿è¡Œ
                capture_output=True,
                text=True,
                timeout=300,             # å¢žåŠ è¶…æ—¶æ—¶é—´
                startupinfo=startupinfo,
                encoding='utf-8',
                errors='ignore',
            )
            
            # æ‰“å° stderr ä»¥ä¾¿è°ƒè¯• (å³ä½¿è¿”å›žç ä¸º 0)
            if completed.stderr:
                logger.debug(f"[parameter_fuzzer] ffuf STDERR: {completed.stderr[:500]}")
                
        except FileNotFoundError as e:
            logger.error(f"[parameter_fuzzer] Execution failed (FileNotFound): {e}")
            return []
        except subprocess.TimeoutExpired:
            logger.error("[parameter_fuzzer] ffuf timed out")
            return []
        except Exception as e:
            logger.error(f"[parameter_fuzzer] Execution error: {e}")
            return []

        # --- è¯»å–å¹¶è§£æžç»“æžœ ---
        discovered_params: List[str] = []
        
        if os.path.exists(temp_output_file):
            try:
                with open(temp_output_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    
                logger.info(f"[parameter_fuzzer] Raw output file '{output_file_name}' size: {len(content)} bytes.")
                
                # ðŸ‘‡ å…³é”®ä¿®å¤ï¼šç¡®ä¿å°† baseline_size ä¼ é€’ç»™è§£æžå‡½æ•°
                discovered_params = self._parse_json_file_content(content, baseline_size)
                
                logger.info(f"[parameter_fuzzer] Full results saved to: {temp_output_file} (File NOT deleted for inspection)")
                
            except IOError as e:
                logger.error(f"[parameter_fuzzer] Could not read temp output file {temp_output_file}: {e}")
            # æ³¨æ„ï¼šè¿™é‡Œæ•…æ„ä¸åˆ é™¤æ–‡ä»¶ï¼Œæ–¹ä¾¿ç”¨æˆ·æŸ¥çœ‹ test.txt
        else:
            logger.warning(f"[parameter_fuzzer] Output file {temp_output_file} was not created. Return code: {completed.returncode}")
        
        logger.info(
            f"[parameter_fuzzer] Analysis complete. Found {len(discovered_params)} potential parameters for {url}."
        )
        return discovered_params

    def _parse_json_file_content(self, content: str, baseline_size: int) -> List[str]:
        """
        è§£æžä»Žä¸´æ—¶æ–‡ä»¶è¯»å–çš„ JSONL å†…å®¹ã€‚
        é€»è¾‘ï¼šæ¯”è¾ƒæ¯ä¸ªç»“æžœçš„ length ä¸Ž baseline_sizeï¼Œå¦‚æžœä¸ç›¸ç­‰ï¼Œåˆ™è§†ä¸ºæœ‰æ•ˆå‚æ•°ã€‚
        """
        params = set()
        lines = content.splitlines()
        
        logger.info(f"[parameter_fuzzer] Parsing results with baseline_size: {baseline_size}")

        for line in lines:
            line = line.strip()
            if not line:
                continue
            try:
                # ffuf çš„ JSON è¾“å‡ºå¯èƒ½åŒ…å«å¼€å¤´çš„é…ç½®å—å’Œç»“å°¾çš„ç»Ÿè®¡å—ï¼Œéœ€è¦å°è¯•è§£æžæ¯ä¸€è¡Œ
                # æœ‰æ•ˆçš„ç»“æžœè¡Œé€šå¸¸æ˜¯ {"input": ..., "status": ...}
                json_obj = json.loads(line)
                
                # è·³è¿‡é…ç½®å— (é€šå¸¸åŒ…å« "config" é”®ä¸”æ²¡æœ‰ "input" æˆ– "status")
                if "config" in json_obj and "input" not in json_obj:
                    continue
                
                input_data = json_obj.get("input", {})
                fuzz_value = input_data.get("FUZZ")
                response_length = json_obj.get("length", 0)
                status_code = json_obj.get("status", 0)
                
                if fuzz_value and isinstance(fuzz_value, str):
                    # ç¡®ä¿å€™é€‰å‚æ•°åæ˜¯ç”±å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ã€è¿žå­—ç¬¦ç»„æˆ
                    if re.fullmatch(r'[a-zA-Z0-9_-]+', fuzz_value):
                        
                        # æ ¸å¿ƒåˆ¤æ–­é€»è¾‘
                        if baseline_size != -1:
                            # å¦‚æžœå“åº”é•¿åº¦ä¸ŽåŸºå‡†é•¿åº¦ä¸åŒï¼Œè¯´æ˜Žå‚æ•°è¢«æœåŠ¡å™¨å¤„ç†äº†
                            if response_length != baseline_size:
                                params.add(fuzz_value)
                                diff = response_length - baseline_size
                                logger.info(f"[parameter_fuzzer] âœ… FOUND PARAM: {fuzz_value} | Status: {status_code} | Len: {response_length} (Base: {baseline_size}, Diff: {diff})")
                            else:
                                # é•¿åº¦ç›¸åŒï¼Œè§†ä¸ºæ— æ•ˆå‚æ•° (å™ªéŸ³)
                                logger.debug(f"[parameter_fuzzer] âšª Skip (Same Len): {fuzz_value} | Len: {response_length}")
                        else:
                            # å¦‚æžœæ²¡æœ‰èŽ·å–åˆ°åŸºå‡†çº¿ï¼Œä¿å®ˆèµ·è§ä¸è‡ªåŠ¨åˆ¤å®šï¼Œæˆ–è€…å¯ä»¥è®°å½•æ‰€æœ‰
                            logger.warning(f"[parameter_fuzzer] No baseline available, skipping auto-filter for {fuzz_value}")
                    
            except json.JSONDecodeError:
                # å¿½ç•¥éž JSON è¡Œ (å¦‚ ffuf çš„è¿›åº¦æ¡è¾“å‡ºå¦‚æžœæ··å…¥äº†æ–‡ä»¶)
                continue
            except Exception as e:
                logger.error(f"[parameter_fuzzer] Error processing line: {e}")
                continue
        
        return list(params)

    def build_urls_with_params(self, base_url: str, params: List[str]) -> List[str]:
        urls: List[str] = []
        for param in params:
            test_value = "1"
            if "?" in base_url:
                url = f"{base_url}&{param}={test_value}"
            else:
                url = f"{base_url}?{param}={test_value}"
            urls.append(url)
        return urls


class ParameterFuzzerAgent(BaseAgent):
    """
    ä½¿ç”¨ ffuf è¿›è¡Œå‚æ•°æ¨¡ç³Šæµ‹è¯•çš„å­ AIã€‚
    """

    name = "Parameter Fuzzer"

    def __init__(self, wordlist_rel_path: str | None = None, match_codes: str | None = "200,301,302") -> None:
        self.fuzzer = ParameterFuzzer(wordlist_rel_path, match_codes)
        self.urls_to_test: List[str] = []

    def _is_promising_for_params(self, url: str, status: int) -> bool:
        if status != 200:
            return False

        url_lower = url.lower()

        if "?" in url:
            return True

        keywords = [
            "login", "signin", "register", "search", "query",
            "sqli", "user", "account", "profile", "admin",
            "list", "detail", "index", "main", "home"
        ]
        if any(kw in url_lower for kw in keywords):
            return True

        return self.fuzzer._is_valid_url_for_fuzzing(url)

    def run(self, context: Dict[str, Any]) -> AgentResult:
        urls: List[Dict[str, Any]] = context.get("urls") or []

        if not isinstance(urls, list):
            return AgentResult(
                name=self.name,
                success=False,
                error="context['urls'] å¿…é¡»æ˜¯åˆ—è¡¨",
            )

        selected: List[str] = []
        summaries: List[str] = []

        logger.info(
            f"[parameter_fuzzer_agent] Received {len(urls)} URLs for parameter fuzzing decision"
        )

        for item in urls:
            if not isinstance(item, dict):
                continue
            base_url = item.get("url")
            status = int(item.get("status", 0))
            if not isinstance(base_url, str) or not base_url:
                continue

            if not self._is_promising_for_params(base_url, status):
                logger.debug(
                    f"[parameter_fuzzer_agent] Skip URL for fuzzing (not promising): {base_url} (status: {status})"
                )
                continue

            selected.append(base_url)

        logger.info(
            f"[parameter_fuzzer_agent] Selected {len(selected)} URLs for ffuf parameter fuzzing"
        )

        urls_to_test: List[str] = []

        for base_url in selected:
            params = self.fuzzer.fuzz_parameters(base_url)

            if params:
                param_urls = self.fuzzer.build_urls_with_params(base_url, params)
                urls_to_test.extend(param_urls)
                summaries.append(
                    f"{base_url} -> params {params} -> {len(param_urls)} URLs"
                )
                logger.info(
                    f"[parameter_fuzzer_agent] {base_url} fuzzed, found params {params}, generated {len(param_urls)} URLs"
                )
            else:
                if "?" in base_url or self.fuzzer._is_valid_url_for_fuzzing(base_url):
                    urls_to_test.append(base_url)
                    summaries.append(f"{base_url} -> no params found, test original")
                    logger.info(
                        f"[parameter_fuzzer_agent] {base_url} no params found, will test original URL"
                    )

        self.urls_to_test = urls_to_test

        details = f"Parameter fuzzing completed. Full raw logs saved to 'test.txt' in ffuf directory. Total URLs to test: {len(urls_to_test)}"
        raw_output = "\n".join(summaries)

        return AgentResult(
            name=self.name,
            success=True,
            vuln=None,
            details=details,
            raw_output=raw_output,
            risk=None,
        )