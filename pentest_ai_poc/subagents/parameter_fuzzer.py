from __future__ import annotations

import os
import re
import subprocess
import json
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse
import requests

from core.agents import AgentResult, BaseAgent
from core.logger import logger


class ParameterFuzzer:
    """
    参数模糊测试器 (基线比较法 - 最终修正版)
    修正点：
    1. 兼容 ffuf 的 Single JSON (results 列表) 和 JSONL 格式。
    2. 严格对比 baseline_size 识别有效参数。
    3. 【重要】构造新 URL 时，强制保留 &submit=1 参数，确保后端逻辑触发。
    """

    name = "Parameter Fuzzer"

    def __init__(self, wordlist_rel_path: str | None = None, match_codes: str | None = "200,301,302"):
        self.ffuf_base_dir = r"D:\web\信息收集\JS_Extender\ffuf_2.0.0_windows_amd64"
        self.ffuf_exe_abs = os.path.join(self.ffuf_base_dir, "ffuf.exe")
        
        if wordlist_rel_path is None:
            wordlist_rel_path = "1.txt"
        self.wordlist_rel_path = wordlist_rel_path
        self.match_codes = match_codes

    def _get_baseline_size(self, url: str) -> int:
        """获取基准响应大小"""
        try:
            clean_url = url.split('?')[0]
            # 添加随机参数防止缓存
            check_url = f"{clean_url}?_baseline_check={os.urandom(4).hex()}"
            response = requests.get(check_url, timeout=10)
            baseline_size = len(response.content)
            logger.info(f"[parameter_fuzzer] Baseline response size for {clean_url} is {baseline_size} bytes.")
            return baseline_size
        except requests.RequestException as e:
            logger.error(f"[parameter_fuzzer] Failed to get baseline size for {url}: {e}")
            return -1

    def _is_valid_url_for_fuzzing(self, url: str) -> bool:
        """
        URL 有效性预检
        【修改重点】：增强对无后缀文件名（如 /dvwa/vulnerabilities/sqli/）的识别，
        允许此类 URL 进行参数模糊测试，因为它们往往也是动态脚本。
        """
        url_lower = url.lower()
        try:
            parsed = urlparse(url)
        except Exception:
            parsed = None

        # 1. 静态资源与敏感路径黑名单
        skip_patterns = [".htaccess", ".css", ".js", ".jpg", ".png", ".gif", ".ico", "/cgi-bin/", "/server-status", "/server-info", "::$DATA"]
        if any(pattern in url_lower for pattern in skip_patterns):
            return False

        if parsed is not None:
            path = parsed.path or "/"
            
            # 2. 显式允许的动态后缀
            dynamic_extensions = [".php", ".asp", ".aspx", ".jsp", ".do", ".action", ".cgi", ".pl", ".py", ".rb"]
            if any(path.endswith(ext) for ext in dynamic_extensions):
                return True

            # 3. 如果已有查询参数，通常意味着可以传参
            if "?" in url:
                return True

            # 4. 【关键修改】处理无后缀 URL (Directory/Module style)
            # 场景：/dvwa/vulnerabilities/sqli/ 或 /admin/user
            # 策略：如果路径不以静态资源后缀结尾，且路径字符主要由字母、数字、斜杠、连字符、下划线组成，则视为潜在动态脚本
            static_extensions = [".css", ".js", ".jpg", ".jpeg", ".png", ".gif", ".ico", ".svg", ".woff", ".woff2", ".ttf", ".eot", ".xml", ".json", ".txt"]
            is_static_file = any(path.endswith(ext) for ext in static_extensions)
            
            if not is_static_file:
                # 排除根路径 "/" (根路径 fuzz 参数意义不大，除非特定场景，这里保持保守)
                if path != "/":
                    # 检查路径是否只包含安全字符 (字母、数字、/、-、_)
                    # 这能过滤掉一些奇怪的二进制文件或明显非 Web 路径m0cfronvqiianfqrgmdoaovalk
                    clean_path = path.strip('/')
                    if clean_path and re.fullmatch(r'[a-zA-Z0-9/_-]+', clean_path):
                        # 额外检查：如果路径以 '/' 结尾，极有可能是目录映射的脚本 (如 Apache Mod_Rewrite 或框架路由)
                        # 或者路径中间包含明显的关键词 (如 vulnerabilities, admin, login, search 等)
                        keywords_in_path = ["vuln", "admin", "login", "search", "user", "api", "module", "action", "do", "app"]
                        if path.endswith("/") or any(kw in url_lower for kw in keywords_in_path):
                            logger.debug(f"[parameter_fuzzer] Identified potential parameterized URL (no extension): {path}")
                            return True
            
            # 5. 原有兜底逻辑
            if path == "/":
                return True
                
        return False

    def fuzz_parameters(self, url: str) -> List[str]:
        if not isinstance(url, str) or not url.strip():
            return []
        url = url.strip()

        if not self._is_valid_url_for_fuzzing(url):
            logger.debug(f"[parameter_fuzzer] Skipping {url}")
            return []

        # 检查环境
        if not os.path.isdir(self.ffuf_base_dir) or not os.path.isfile(self.ffuf_exe_abs):
            logger.error("[parameter_fuzzer] ffuf executable or directory missing")
            return []

        wordlist_abs = os.path.join(self.ffuf_base_dir, self.wordlist_rel_path)
        if not os.path.isfile(wordlist_abs):
            logger.error(f"[parameter_fuzzer] Wordlist not found: {wordlist_abs}")
            return []

        logger.info(f"[parameter_fuzzer] Starting fuzzing for: {url}")

        # 1. 获取基准线
        baseline_size = self._get_baseline_size(url)

        # 注意：ffuf 测试时依然需要 submit=1 来触发逻辑，以便观察到长度变化
        test_url = f'{url}?FUZZ=1&submit=1'
        output_file_name = "test.txt"
        temp_output_file = os.path.join(self.ffuf_base_dir, output_file_name)

        # 2. 构建命令
        cmd = [
            self.ffuf_exe_abs,
            "-w", wordlist_abs,
            "-u", test_url,
            "-json",
            "-o", output_file_name,
            "-c",
            "-t", "40"
        ]

        try:
            startupinfo = None
            if os.name == 'nt':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW

            completed = subprocess.run(
                cmd,
                cwd=self.ffuf_base_dir,
                capture_output=True,
                text=True,
                timeout=300,
                startupinfo=startupinfo,
                encoding='utf-8',
                errors='ignore',
            )
            if completed.stderr:
                logger.debug(f"[parameter_fuzzer] ffuf STDERR: {completed.stderr[:200]}")
        except Exception as e:
            logger.error(f"[parameter_fuzzer] Execution error: {e}")
            return []

        # 3. 解析结果
        discovered_params = []
        if os.path.exists(temp_output_file):
            try:
                with open(temp_output_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                logger.info(f"[parameter_fuzzer] Raw output file size: {len(content)} bytes.")
                discovered_params = self._parse_json_file_content(content, baseline_size)
                logger.info(f"[parameter_fuzzer] Full results saved to: {temp_output_file}")
            except Exception as e:
                logger.error(f"[parameter_fuzzer] Error reading file: {e}")
        else:
            logger.warning("[parameter_fuzzer] Output file not created.")

        logger.info(f"[parameter_fuzzer] Found {len(discovered_params)} parameters: {discovered_params}")
        return discovered_params

    def _parse_json_file_content(self, content: str, baseline_size: int) -> List[str]:
        """
        兼容解析 ffuf 的 Single JSON (results 列表) 和 JSONL 格式
        """
        params = set()
        results_list = []

        # 尝试作为单个 JSON 对象解析
        try:
            full_json = json.loads(content)
            if isinstance(full_json, dict) and "results" in full_json:
                results_list = full_json["results"]
                logger.info(f"[parameter_fuzzer] Detected Single JSON format. Found {len(results_list)} entries in 'results' list.")
            elif isinstance(full_json, list):
                results_list = full_json
                logger.info(f"[parameter_fuzzer] Detected JSON Array format.")
            else:
                results_list = []
        except json.JSONDecodeError:
            #  fallback 到 JSONL
            logger.debug("[parameter_fuzzer] Single JSON parse failed, assuming JSONL format.")
            lines = content.splitlines()
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                try:
                    obj = json.loads(line)
                    if isinstance(obj, dict) and "input" in obj:
                        results_list.append(obj)
                except json.JSONDecodeError:
                    continue
        
        if not results_list:
            logger.warning("[parameter_fuzzer] No valid results extracted from output file.")
            return []

        logger.info(f"[parameter_fuzzer] Parsing {len(results_list)} results against baseline: {baseline_size}")

        for item in results_list:
            if not isinstance(item, dict):
                continue
                
            input_data = item.get("input", {})
            fuzz_value = input_data.get("FUZZ") if isinstance(input_data, dict) else None
            response_length = item.get("length", 0)
            status_code = item.get("status", 0)

            if fuzz_value and isinstance(fuzz_value, str):
                if re.fullmatch(r'[a-zA-Z0-9_-]+', fuzz_value):
                    if baseline_size != -1 and response_length != baseline_size:
                        params.add(fuzz_value)
                        diff = response_length - baseline_size
                        logger.info(f"[parameter_fuzzer] ✅ FOUND PARAM: '{fuzz_value}' | Status: {status_code} | Len: {response_length} (Base: {baseline_size}, Diff: {diff})")
                    else:
                        logger.debug(f"[parameter_fuzzer] ⚪ Skip: '{fuzz_value}' (Len {response_length} == Base {baseline_size})")
        
        return list(params)

    def build_urls_with_params(self, base_url: str, params: List[str]) -> List[str]:
        """
        构造带有发现参数的新 URL。
        【关键修改】：强制附加 &submit=1，确保后端表单逻辑被触发。
        """
        urls = []
        for param in params:
            # 确定连接符
            if "?" in base_url:
                # 如果已有参数，用 & 连接
                # 结果示例：http://.../page.php?id=1&name=1&submit=1
                url = f"{base_url}&{param}=1&submit=1"
            else:
                # 如果没有参数，用 ? 开始
                # 结果示例：http://.../page.php?name=1&submit=1
                url = f"{base_url}?{param}=1&submit=1"
            
            urls.append(url)
            logger.debug(f"[parameter_fuzzer] Constructed URL: {url}")
            
        return urls


class ParameterFuzzerAgent(BaseAgent):
    """
    参数模糊测试 Agent
    """
    name = "Parameter Fuzzer"

    def __init__(self, wordlist_rel_path: str | None = None, match_codes: str | None = "200,301,302") -> None:
        self.fuzzer = ParameterFuzzer(wordlist_rel_path, match_codes)
        self.urls_to_test: List[str] = []

    def _is_promising_for_params(self, url: str, status: int) -> bool:
        if status != 200: 
            return False
        url_lower = url.lower()
        if "?" in url: 
            return True
        keywords = ["login", "search", "sqli", "user", "admin", "index", "php", "asp", "jsp"]
        if any(kw in url_lower for kw in keywords): 
            return True
        return self.fuzzer._is_valid_url_for_fuzzing(url)

    def run(self, context: Dict[str, Any]) -> AgentResult:
        urls = context.get("urls") or []
        if not isinstance(urls, list):
            return AgentResult(name=self.name, success=False, error="Invalid URLs")

        selected = []
        for item in urls:
            if not isinstance(item, dict): 
                continue
            u = item.get("url")
            s = int(item.get("status", 0))
            if u and self._is_promising_for_params(u, s):
                selected.append(u)

        logger.info(f"[agent] Selected {len(selected)} URLs for fuzzing.")
        
        final_urls = []
        summaries = []

        for base_url in selected:
            params = self.fuzzer.fuzz_parameters(base_url)
            
            if params:
                # 这里生成的 URL 现在会自动包含 &submit=1
                new_urls = self.fuzzer.build_urls_with_params(base_url, params)
                final_urls.extend(new_urls)
                summaries.append(f"{base_url} -> Found params: {params}")                                 #大写
                logger.info(f"[agent] {base_url} -> Generated {len(new_urls)} URLs with params: {params} (includes submit=1)")
            else:
                # 即使没发现新参数，也保留原 URL
                final_urls.append(base_url)
                summaries.append(f"{base_url} -> No new params (testing original)")
                logger.info(f"[agent] {base_url} -> No new params found.")

        self.urls_to_test = final_urls
        return AgentResult(
            name=self.name,
            success=True,
            details=f"Fuzzing done. Total URLs: {len(final_urls)}",
            raw_output="\n".join(summaries)
        )