from __future__ import annotations

import os
import re
import subprocess
from typing import Any, Dict, List
from urllib.parse import urlparse

from core.agents import AgentResult, BaseAgent
from core.logger import logger


class ParameterFuzzer:
    """
    参数模糊测试器，使用 ffuf 工具对 URL 进行参数爆破。
    发现参数后，构造带参数的完整 URL 供子 AI 测试。
    """

    name = "Parameter Fuzzer"

    def __init__(self, wordlist_path: str | None = None):
        """
        初始化参数模糊测试器。

        参数:
            wordlist_path: ffuf 字典路径，默认为指定路径
        """
        if wordlist_path is None:
            wordlist_path = r"D:\web\信息收集\JS_Extender\ffuf_2.0.0_windows_amd64\fuzz字典-top3000.txt"
        self.wordlist_path = wordlist_path

    def _is_valid_url_for_fuzzing(self, url: str) -> bool:
        """
        判断 URL 是否适合进行参数模糊测试。
        跳过静态资源、目录等。
        """
        url_lower = url.lower()

        # 尝试解析 URL，用于判断是否是根路径（如 http://host:81/）
        try:
            parsed = urlparse(url)
        except Exception:
            parsed = None
        # 跳过明显的静态资源或目录
        skip_patterns = [
            ".htaccess",
            ".css",
            ".js",
            ".jpg",
            ".png",
            ".gif",
            ".ico",
            "/cgi-bin/",
            "/server-status",
            "/server-info",
            "::$DATA",
        ]
        if any(pattern in url_lower for pattern in skip_patterns):
            return False

        # 如果是纯根路径（/ 或空路径），也认为值得测试
        # 例如：http://8734f5b5-8f1c-4885-89ff-2a098dc1228e.node5.buuoj.cn:81/
        if parsed is not None:
            path = parsed.path or "/"
            if path == "/" and "?" not in url:
                return True

        # 优先测试 PHP、ASP、JSP 等动态页面
        dynamic_extensions = [".php", ".asp", ".aspx", ".jsp", ".do", ".action"]
        if any(url_lower.endswith(ext) for ext in dynamic_extensions):
            return True
        # 如果 URL 没有扩展名但看起来像页面（不是目录），也可以测试
        if not url.endswith("/") and "?" not in url:
            return True
        return False

    def fuzz_parameters(self, url: str) -> List[str]:
        """
        对目标 URL 进行参数模糊测试。

        参数:
            url: 目标 URL（如 "http://192.168.101.103/pikachu/vul/sqli/sqli_str.php"）

        返回:
            List[str]: 发现的参数列表，如 ["id", "user", "name"]
            若无参数发现，返回空列表。
        """
        if not isinstance(url, str) or not url.strip():
            logger.error("[parameter_fuzzer] Invalid URL")
            return []

        url = url.strip()

        # 判断是否适合进行参数模糊测试
        if not self._is_valid_url_for_fuzzing(url):
            logger.debug(f"[parameter_fuzzer] Skipping parameter fuzzing for {url} (not suitable)")
            return []

        # 检查字典文件是否存在
        if not os.path.isfile(self.wordlist_path):
            logger.error(f"[parameter_fuzzer] Wordlist not found: {self.wordlist_path}")
            return []

        logger.info(f"[parameter_fuzzer] Starting parameter fuzzing for: {url}")

        # 构造 ffuf 命令
        # ffuf -u "http://target.com/path?FUZZ=test" -w dict.txt -mc 200,403 -t 10
        # 使用 FUZZ 占位符，ffuf 会用字典中的词替换
        test_url = f"{url}?FUZZ=../index.html&submit=%E6%9F%A5%E8%AF%A2"
        cmd: List[str] = [
            "ffuf",
            "-u",
            test_url,
            "-w",
            self.wordlist_path,
            "-mc",
            "200,403",  # 匹配状态码 200 或 403
            "-t",
            "30",  # 线程数
            "-timeout",
            "100",  # 超时时间
            # 不使用 -s，保留输出以便解析
        ]
        
        logger.debug(f"[parameter_fuzzer] Executing command: {' '.join(cmd)}")

        try:
            completed = subprocess.run(
                cmd,
                shell=False,
                capture_output=True,
                text=True,
                timeout=60,  # 总超时 60 秒
            )
        except FileNotFoundError:
            logger.error("[parameter_fuzzer] ffuf not found in PATH")
            return []
        except subprocess.TimeoutExpired:
            logger.error("[parameter_fuzzer] ffuf timed out")
            return []

        stdout = completed.stdout or ""
        stderr = completed.stderr or ""

        # 记录原始输出用于调试
        if stdout:
            logger.debug(f"[parameter_fuzzer] ffuf stdout (first 500 chars): {stdout[:500]}")
        if stderr:
            logger.debug(f"[parameter_fuzzer] ffuf stderr (first 500 chars): {stderr[:500]}")

        # 解析 ffuf 输出，提取发现的参数
        # ffuf 输出格式示例（表格格式）：
        # :: Method           : GET
        # :: URL              : http://target.com/path?FUZZ=test
        # :: Wordlist         : FUZZ: dict.txt
        # 
        # [Status: 200] [Size: 1234] [Words: 56] [Lines: 12] id
        # [Status: 200] [Size: 1234] [Words: 56] [Lines: 12] user
        # 
        # 或者更简洁的格式：
        # id                    [Status: 200, Size: 1234, Words: 56, Lines: 12]
        discovered_params: List[str] = []

        # 模式1: 从输出行中提取参数名（ffuf 输出中，参数名通常在行首或 URL 中）
        # 查找包含状态码和参数名的行
        # 格式：参数名 [Status: 200, Size: ...]
        pattern1 = re.compile(r"^([a-zA-Z0-9_]+)\s+\[Status:\s+\d+")
        # 格式：[Status: 200] ... 参数名
        pattern2 = re.compile(r"\[Status:\s+\d+\].*?([a-zA-Z0-9_]+)\s*$")
        # 格式：从完整 URL 中提取参数
        pattern3 = re.compile(rf"{re.escape(url)}\?([a-zA-Z0-9_]+)=")

        all_lines = (stdout + "\n" + stderr).splitlines()
        logger.debug(f"[parameter_fuzzer] Parsing {len(all_lines)} lines from ffuf output")

        for line in all_lines:
            line = line.strip()
            if not line:
                continue

            # 跳过 ffuf 的头部信息行
            if line.startswith("::") or line.startswith("=") or "Method" in line or "URL" in line:
                continue

            param_name = None

            # 尝试模式1：参数名在行首
            match = pattern1.search(line)
            if match:
                param_name = match.group(1)
            else:
                # 尝试模式2：参数名在行尾
                match = pattern2.search(line)
                if match:
                    param_name = match.group(1)
                else:
                    # 尝试模式3：从完整 URL 中提取
                    match = pattern3.search(line)
                    if match:
                        param_name = match.group(1)

            if param_name and param_name not in discovered_params:
                # 过滤掉明显不是参数名的词（如 "FUZZ", "Status", "Size" 等）
                if param_name.lower() not in ["fuzz", "status", "size", "words", "lines", "time"]:
                    discovered_params.append(param_name)
                    logger.debug(f"[parameter_fuzzer] Found parameter: {param_name} (from line: {line[:80]})")

        logger.info(
            f"[parameter_fuzzer] Found {len(discovered_params)} parameters for {url}: {discovered_params}"
        )

        return discovered_params

    def build_urls_with_params(self, base_url: str, params: List[str]) -> List[str]:
        """
        根据发现的参数构造带参数的完整 URL。

        参数:
            base_url: 基础 URL（如 "http://target.com/path.php"）
            params: 参数名列表（如 ["id", "user"]）

        返回:
            List[str]: 带参数的 URL 列表，如：
            ["http://target.com/path.php?id=1", "http://target.com/path.php?user=test"]
        """
        urls: List[str] = []
        for param in params:
            # 构造测试 URL，使用常见的测试值
            test_value = "1"  # 简单测试值
            if "?" in base_url:
                # URL 已有参数，使用 & 连接
                url = f"{base_url}&{param}={test_value}"
            else:
                # URL 无参数，使用 ? 连接
                url = f"{base_url}?{param}={test_value}"
            urls.append(url)
        return urls


class ParameterFuzzerAgent(BaseAgent):
    """
    使用 ffuf 进行参数模糊测试的子 AI。

    由它来决定：
    1. 哪些 URL 适合做参数 fuzz（减少盲目测试）
    2. 为后续 SQLi/XSS 子 AI 生成带参数的测试 URL 列表

    约定：
    - run(context) 的 context 结构：
        {
            "urls": List[Dict[str, Any]]  # Dirsearch 发现的 URL 列表，每项至少包含 {"url": str, "status": int}
        }
    - 运行结束后：
        - self.urls_to_test: List[str] 带参数或原始的测试 URL
        - 返回 AgentResult，用于 UI 展示此子 AI 的执行情况
    """

    name = "Parameter Fuzzer"

    def __init__(self, wordlist_path: str | None = None) -> None:
        self.fuzzer = ParameterFuzzer(wordlist_path)
        self.urls_to_test: List[str] = []

    def _is_promising_for_params(self, url: str, status: int) -> bool:
        """
        决定是否值得对该 URL 尝试参数 fuzz。

        策略：
        - 仅考虑 200 响应（一般是可访问页面）
        - 仅考虑动态或与交互相关的路径（login、search、sqli 等）
        """
        if status != 200:
            return False

        url_lower = url.lower()

        # 如果 URL 已经带有参数，优先考虑
        if "?" in url:
            return True

        # 结合业务关键词，优先 fuzz 这些路径
        keywords = [
            "login",
            "signin",
            "register",
            "search",
            "query",
            "sqli",
            "user",
            "account",
            "profile",
            "admin",
            "list",
            "detail",
        ]
        if any(kw in url_lower for kw in keywords):
            return True

        # 交给底层 fuzzer 的静态过滤再做一层兜底判断
        return self.fuzzer._is_valid_url_for_fuzzing(url)

    def run(self, context: Dict[str, Any]) -> AgentResult:
        urls: List[Dict[str, Any]] = context.get("urls") or []

        if not isinstance(urls, list):
            return AgentResult(
                name=self.name,
                success=False,
                error="context['urls'] 必须是列表",
            )

        selected: List[str] = []
        summaries: List[str] = []

        logger.info(
            f"[parameter_fuzzer_agent] Received {len(urls)} URLs from Dirsearch for parameter fuzzing decision"
        )

        # 先筛选出值得 fuzz 的 URL（只是一部分）
        for item in urls:
            if not isinstance(item, dict):
                continue
            base_url = item.get("url")
            status = int(item.get("status", 0))
            if not isinstance(base_url, str) or not base_url:
                continue

            if not self._is_promising_for_params(base_url, status):
                logger.debug(
                    f"[parameter_fuzzer_agent] Skip URL for fuzzing (not promising): {base_url} (status: {status})"
                )
                continue

            selected.append(base_url)

        logger.info(
            f"[parameter_fuzzer_agent] Selected {len(selected)} URLs for ffuf parameter fuzzing"
        )

        urls_to_test: List[str] = []

        # 对筛选出的 URL 再调用 ffuf 进行参数 fuzz
        for base_url in selected:
            params = self.fuzzer.fuzz_parameters(base_url)

            if params:
                param_urls = self.fuzzer.build_urls_with_params(base_url, params)
                urls_to_test.extend(param_urls)
                summaries.append(
                    f"{base_url} -> params {params} -> {len(param_urls)} URLs"
                )
                logger.info(
                    f"[parameter_fuzzer_agent] {base_url} fuzzed, found params {params}, generated {len(param_urls)} URLs"
                )
            else:
                # 如果没有发现参数，但 URL 已经有 query 或看起来很有可能有参数，也可以直接测试原始 URL
                if "?" in base_url or self.fuzzer._is_valid_url_for_fuzzing(base_url):
                    urls_to_test.append(base_url)
                    summaries.append(f"{base_url} -> no params found, test original")
                    logger.info(
                        f"[parameter_fuzzer_agent] {base_url} no params found, will test original URL"
                    )

        self.urls_to_test = urls_to_test

        details = (
            f"Parameter fuzzing completed, total URLs to test: {len(urls_to_test)}"
        )
        raw_output = "\n".join(summaries)

        return AgentResult(
            name=self.name,
            success=True,
            vuln=None,
            details=details,
            raw_output=raw_output,
            risk=None,
        )
