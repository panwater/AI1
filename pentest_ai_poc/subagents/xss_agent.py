from __future__ import annotations

import random
import string
from typing import Any, Dict, List, Tuple
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

import requests

from core.agents import AgentResult, BaseAgent
from core.logger import logger
from core.report_generator import generate_standard_vuln_report, save_report_to_file


class XSSAgent(BaseAgent):
    """
    轻量级 XSS 测试子 AI。
    通过注入随机 Payload 并检测未转义的回显来判断潜在漏洞。
    """

    name = "XSS Tester"
    
    # 定义一些常见的 XSS 探测 Payload，包含随机特征码以便识别
    # 使用随机后缀防止缓存干扰
    def _generate_payload(self) -> str:
        rand_str = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))
        return f"<XSS_TEST_{rand_str}>"

    def _get_params_from_url(self, url: str) -> List[str]:
        """提取 URL 中的 GET 参数名"""
        parsed = urlparse(url)
        query_params = parse_qs(parsed.query)
        return list(query_params.keys())

    def _test_parameter(self, base_url: str, param_name: str, session: requests.Session) -> Tuple[bool, str]:
        """
        测试单个参数是否存在反射型 XSS
        返回: (是否脆弱, 发现的 payload)
        """
        payload = self._generate_payload()
        
        # 重新构建带 Payload 的 URL
        parsed = urlparse(base_url)
        query_params = parse_qs(parsed.query, keep_blank_values=True)
        
        # 注入 payload (覆盖原值)
        query_params[param_name] = [payload]
        
        # 重新编码查询字符串
        new_query = urlencode(query_params, doseq=True)
        new_url = urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            new_query,
            parsed.fragment
        ))

        try:
            resp = session.get(
                new_url,
                timeout=10,
                headers={"User-Agent": "pentest-ai-xss-agent/1.0"},
                verify=False,
                allow_redirects=True # 跟随重定向，有时重定向后也会回显
            )
            
            body = resp.text
            
            # 检查 1: Payload 是否在响应中？
            if payload not in body:
                return False, ""
            
            # 检查 2: Payload 是否被转义了？
            # 如果 < 变成了 &lt; 或 > 变成了 &gt;，则通常是安全的
            escaped_variants = [
                payload.replace("<", "&lt;").replace(">", "&gt;"),
                payload.replace("<", "&lt;"),
                payload.replace(">", "&gt;"),
                payload.replace('"', "&quot;"),
                payload.replace("'", "&#x27;")
            ]
            
            is_escaped = any(variant in body for variant in escaped_variants)
            
            # 如果找到了原始 payload 且没有被常见方式转义，则判定为可疑
            # 注意：这只是一个启发式判断，最准确的方法是检查上下文（如在 <script> 标签内还是属性内）
            if not is_escaped:
                logger.info(f"[xss_agent] Potential XSS found in parameter '{param_name}': {payload} reflected unescaped.")
                return True, payload
            
            # 边缘情况：有时部分转义或特定上下文（如在 JS 变量中）可能仍可利用，
            # 但为了简化版 agent，我们保守一点，如果明显转义了就认为安全。
            return False, ""

        except Exception as e:
            logger.warning(f"[xss_agent] Error testing param {param_name}: {e}")
            return False, ""

    def run(self, context: Dict[str, Any]) -> AgentResult:
        url = context.get("url", "")
        if not isinstance(url, str) or not url:
            return AgentResult(
                name=self.name,
                success=False,
                error="无效的 URL",
            )

        parsed = urlparse(url)
        # 仅支持 GET 参数的简单测试
        params = self._get_params_from_url(url)
        
        if not params:
            logger.info(f"[xss_agent] No GET parameters found in {url}. Skipping simple reflection test.")
            return AgentResult(
                name=self.name,
                success=False,
                details="URL 中未发现 GET 参数，无法进行简单的反射型 XSS 启发式测试。",
                risk="低",
            )

        logger.info(f"[xss_agent] Testing {len(params)} parameters for XSS on {url}")
        
        session = requests.Session()
        session.verify = False
        session.headers.update({"User-Agent": "pentest-ai-xss-agent/1.0"})

        vulnerable_param = None
        found_payload = None

        for param in params:
            is_vuln, payload = self._test_parameter(url, param, session)
            if is_vuln:
                vulnerable_param = param
                found_payload = payload
                break # 发现一个就停止，避免过多请求

        if vulnerable_param:
            logger.info(f"[xss_agent] XSS vulnerability likely found in parameter: {vulnerable_param}")

            target_unit = parsed.hostname or parsed.netloc or "unknown"

            # 构建 PoC
            poc_url = url.replace(f"{vulnerable_param}=", f"{vulnerable_param}={found_payload}")
            poc = (
                f"1. 访问以下 URL (参数 '{vulnerable_param}' 被注入):\n"
                f"{poc_url}\n\n"
                f"2. 观察页面源码或 DOM，确认标签 <XSS_TEST_...> 未被转义并可能被浏览器解析。"
            )

            details = (
                f"检测到参数 '{vulnerable_param}' 存在反射型 XSS 风险。\n"
                f"测试 Payload '{found_payload}' 被服务器原样返回且未进行有效的 HTML 实体编码。\n"
                f"攻击者可构造恶意链接，诱导用户点击后在受害者浏览器中执行任意 JavaScript 代码。"
            )

            brief_desc = (
                "应用程序未对用户输入进行有效过滤和转义，"
                "导致攻击者可注入恶意脚本，造成会话劫持、钓鱼攻击或数据窃取。"
            )

            try:
                report = generate_standard_vuln_report(
                    target_unit=target_unit,
                    vuln_type="跨站脚本 (XSS)",
                    url=url,
                    brief_desc=brief_desc,
                    poc=poc,
                    details=details,
                )
                report_filename = save_report_to_file(report, target_unit)
            except Exception as exc:
                logger.error(f"[xss_agent] Failed to generate report: {exc}")
                report = ""
                report_filename = ""

            return AgentResult(
                name=self.name,
                success=True,
                vuln="Reflected XSS",
                poc=poc,
                details=details,
                raw_output=f"Tested Payload: {found_payload}",
                risk="高", # XSS 通常定为高或中，取决于利用难度，这里暂定高
                report=report,
                report_filename=report_filename,
            )

        logger.info(f"[xss_agent] No reflected XSS patterns confirmed for tested parameters.")
        return AgentResult(
            name=self.name,
            success=False,
            details="对 URL 中的参数进行了反射测试，未发现明显的未转义回显。",
            raw_output=None,
            risk="低",
        )