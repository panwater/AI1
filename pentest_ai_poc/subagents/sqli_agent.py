from __future__ import annotations

import re
import subprocess
from typing import Any, Dict, List
from urllib.parse import urlparse

from core.agents import AgentResult, BaseAgent
from core.logger import logger
from core.report_generator import generate_standard_vuln_report, save_report_to_file


_SAFE_URL_PATTERN = re.compile(r"^[a-zA-Z0-9:/?&=%._\-#]+$")


class SQLiAgent(BaseAgent):
    """
    使用 sqlmap 进行 SQL 注入测试的子 AI。
    """

    name = "SQLi Tester"

    def _is_safe_url(self, url: str) -> bool:
        return bool(_SAFE_URL_PATTERN.match(url))

    def run(self, context: Dict[str, Any]) -> AgentResult:
        url = context.get("url", "")
        if not isinstance(url, str) or not url:
            return AgentResult(
                name=self.name,
                success=False,
                error="无效的 URL",
            )

        if not self._is_safe_url(url):
            return AgentResult(
                name=self.name,
                success=False,
                error="URL 含有非法字符，已拒绝执行 sqlmap",
            )

        # 修改后的命令构建：使用 python 绝对路径执行 sqlmap.py
        # 注意：确保此路径与您系统中的实际路径一致
        cmd: List[str] = [
            "python", # 或者您可以使用 python.exe 的完整路径，如 "C:\\Python39\\python.exe"
            r"D:\web\tool\ONE-FOX集成工具箱_V8公开版_by狐狸\gui_scan\sqlmap\sqlmap.py", # sqlmap.py 的绝对路径
            "-u",
            url,
            "--batch",
            "--risk",
            "2",
            "--level",
            "3",
            "--disable-coloring",
          #  "--cookie", "security=low; PHPSESSID=tqb58putpkr3p2d23omh1lvq5f",
        ]

        logger.info(f"[sqli_agent] Starting sqlmap for URL: {url} using command: {' '.join(cmd)}")

        try:
            completed = subprocess.run(
                cmd,
                check=False,
                capture_output=True,
                text=True,
                timeout=300,  # 避免长时间阻塞
            )
        except FileNotFoundError:
            logger.error("[sqli_agent] Python interpreter or sqlmap.py not found at the specified path.")
            logger.error("[sqli_agent] Please ensure 'python' is in your PATH and the sqlmap.py path is correct.")
            return AgentResult(
                name=self.name,
                success=False,
                error="Python 解释器或指定路径下的 sqlmap.py 文件未找到。",
            )
        except subprocess.TimeoutExpired:
            logger.error("[sqli_agent] sqlmap timed out")
            return AgentResult(
                name=self.name,
                success=False,
                error="sqlmap 执行超时。",
            )

        stdout = completed.stdout or ""
        stderr = completed.stderr or ""

        if completed.returncode != 0:
            # 注意：sqlmap 即使发现漏洞，有时 returncode 也可能是 0，
            # 但如果是因为错误退出（如网络不可达），returncode 非 0 且无输出，则视为失败。
            # 这里我们主要依赖输出内容判断，不单纯依赖 returncode
            logger.warning(
                f"[sqli_agent] sqlmap exited with code {completed.returncode} for {url}"
            )

        # --- 修改开始 ---
        text = (stdout + "\n" + stderr).lower()
        
        # 更准确的判断逻辑：
        # 1. "injection point" : sqlmap 找到注入点的标准提示
        # 2. "payload:" : 列出了具体的攻击载荷，意味着肯定有漏洞
        # 3. "is vulnerable" : 保留原有的兼容逻辑
        vulnerable = (
            "injection point" in text or 
            "payload:" in text or 
            "is vulnerable" in text
        )
        # --- 修改结束 ---

        if vulnerable:
            logger.info(f"[sqli_agent] SQL Injection likely found for {url}")

            # 提取目标单位
            parsed = urlparse(url)
            target_unit = parsed.hostname or parsed.netloc or "unknown"

            # 构建 PoC (保持原样)
            poc = 'python "D:\\web\\tool\\ONE-FOX集成工具箱_V8公开版_by狐狸\\gui_scan\\sqlmap\\sqlmap.py" -u "' + url + '" --batch --risk 2 --level 3 --disable-coloring'

            # 构建详细描述
            details = (
                "通过 sqlmap 自动化工具检测到 SQL 注入漏洞。"
                "在目标 URL 的参数中注入恶意 SQL 语句可执行任意数据库查询，"
                "可能导致数据泄露、数据篡改或系统接管。\n\n"
                "检测到的注入类型包括:\n"
                # 可选：尝试简单提取一下类型，或者直接放原始输出摘要
                + (stdout.split("---")[1].split("---")[0] if "---" in stdout else "详见原始输出") 
                + "\n\nsqlmap 输出中检测到明确的注入点 (Injection Point) 和 Payload。"
            )

            # 构建简要描述
            brief_desc = (
                "应用程序未对用户输入进行有效过滤，"
                "导致攻击者可执行任意 SQL 查询，可能造成数据泄露或系统接管。"
            )

            # 生成标准格式报告
            try:
                report = generate_standard_vuln_report(
                    target_unit=target_unit,
                    vuln_type="SQL 注入",
                    url=url,
                    brief_desc=brief_desc,
                    poc=poc,
                    details=details,
                )
                report_filename = save_report_to_file(report, target_unit)
            except Exception as exc:
                logger.error(f"[sqli_agent] Failed to generate report: {exc}")
                report = ""
                report_filename = ""

            return AgentResult(
                name=self.name,
                success=True,
                vuln="SQL Injection",
                poc=poc,
                details=details,
                raw_output=stdout,
                risk="高",
                report=report,
                report_filename=report_filename,
            )

        logger.info(f"[sqli_agent] No SQL Injection confirmed for {url}")
        return AgentResult(
            name=self.name,
            success=False,
            vuln=None,
            details="未在 sqlmap 输出中发现明显的注入点 (Injection Point) 或 Payload。",
            raw_output=stdout,
            risk="低",
        )