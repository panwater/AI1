from __future__ import annotations

import re
import subprocess
from typing import Any, Dict, List
from urllib.parse import urlparse

from core.agents import AgentResult, BaseAgent
from core.logger import logger
from core.report_generator import generate_standard_vuln_report, save_report_to_file


_SAFE_URL_PATTERN = re.compile(r"^[a-zA-Z0-9:/?&=%._\-#]+$")


class SQLiAgent(BaseAgent):
    """
    使用 sqlmap 进行 SQL 注入测试的子 AI。
    """

    name = "SQLi Tester"

    def _is_safe_url(self, url: str) -> bool:
        return bool(_SAFE_URL_PATTERN.match(url))

    def run(self, context: Dict[str, Any]) -> AgentResult:
        url = context.get("url", "")
        if not isinstance(url, str) or not url:
            return AgentResult(
                name=self.name,
                success=False,
                error="无效的 URL",
            )

        if not self._is_safe_url(url):
            return AgentResult(
                name=self.name,
                success=False,
                error="URL 含有非法字符，已拒绝执行 sqlmap",
            )

        # 修改后的命令构建：使用 python 绝对路径执行 sqlmap.py
        # 注意：确保此路径与您系统中的实际路径一致
        cmd: List[str] = [
            "python", # 或者您可以使用 python.exe 的完整路径，如 "C:\\Python39\\python.exe"
            r"D:\web\tool\ONE-FOX集成工具箱_V8公开版_by狐狸\gui_scan\sqlmap\sqlmap.py", # sqlmap.py 的绝对路径
            "-u",
            url,
            "--batch",
            "--risk",
            "2",
            "--level",
            "3",
            "--disable-coloring",
        ]

        logger.info(f"[sqli_agent] Starting sqlmap for URL: {url} using command: {' '.join(cmd)}")

        try:
            completed = subprocess.run(
                cmd,
                check=False,
                capture_output=True,
                text=True,
                timeout=300,  # 避免长时间阻塞
            )
        except FileNotFoundError:
            logger.error("[sqli_agent] Python interpreter or sqlmap.py not found at the specified path.")
            logger.error("[sqli_agent] Please ensure 'python' is in your PATH and the sqlmap.py path is correct.")
            return AgentResult(
                name=self.name,
                success=False,
                error="Python 解释器或指定路径下的 sqlmap.py 文件未找到。",
            )
        except subprocess.TimeoutExpired:
            logger.error("[sqli_agent] sqlmap timed out")
            return AgentResult(
                name=self.name,
                success=False,
                error="sqlmap 执行超时。",
            )

        stdout = completed.stdout or ""
        stderr = completed.stderr or ""

        if completed.returncode != 0:
            logger.warning(
                f"[sqli_agent] sqlmap exited with code {completed.returncode} for {url}"
            )

        # 极简输出解析：查找是否存在明显的注入成功提示
        text = (stdout + "\n" + stderr).lower()
        vulnerable = "is vulnerable" in text or "sql injection" in text

        if vulnerable:
            logger.info(f"[sqli_agent] SQL Injection likely found for {url}")

            # 提取目标单位（从 URL 中提取 hostname）
            parsed = urlparse(url)
            target_unit = parsed.hostname or parsed.netloc or "unknown"

            # 构建 PoC
            # PoC 也相应更新为使用 python 调用
            poc = 'python "D:\\web\\tool\\ONE-FOX集成工具箱_V8公开版_by狐狸\\gui_scan\\sqlmap\\sqlmap.py" -u "' + url + '" --batch --risk 2 --level 3 --disable-coloring'

            # 构建详细描述
            details = (
                "通过 sqlmap 自动化工具检测到 SQL 注入漏洞。"
                "在目标 URL 的参数中注入恶意 SQL 语句可执行任意数据库查询，"
                "可能导致数据泄露、数据篡改或系统接管。"
                "sqlmap 输出中检测到注入成功的明确提示。"
            )

            # 构建简要描述（不包含 URL、IP、PoC 等具体信息）
            brief_desc = (
                "应用程序未对用户输入进行有效过滤，"
                "导致攻击者可执行任意 SQL 查询，可能造成数据泄露或系统接管。"
            )

            # 生成标准格式报告
            try:
                report = generate_standard_vuln_report(
                    target_unit=target_unit,
                    vuln_type="SQL 注入",
                    url=url,
                    brief_desc=brief_desc,
                    poc=poc,
                    details=details,
                )
                # 保存报告到文件
                report_filename = save_report_to_file(report, target_unit)
            except Exception as exc:
                logger.error(f"[sqli_agent] Failed to generate report: {exc}")
                report = ""
                report_filename = ""

            return AgentResult(
                name=self.name,
                success=True,
                vuln="SQL Injection",
                poc=poc,
                details=details,
                raw_output=stdout,
                risk="高",
                report=report,  # 标准格式报告
                report_filename=report_filename,  # 报告文件名
            )

        logger.info(f"[sqli_agent] No SQL Injection confirmed for {url}")
        return AgentResult(
            name=self.name,
            success=False,
            vuln=None,
            details="未在 sqlmap 输出中发现明显的 SQL 注入成功提示。",
            raw_output=stdout,
            risk="低",
        )