import os
from pathlib import Path
from typing import Any, Dict
from urllib.parse import urlparse

from fastapi import FastAPI, Form, HTTPException, Request  # pyright: ignore[reportMissingImports]
from fastapi.responses import FileResponse, HTMLResponse  # pyright: ignore[reportMissingImports]
from fastapi.staticfiles import StaticFiles  # pyright: ignore[reportMissingImports]
from fastapi.templating import Jinja2Templates  # pyright: ignore[reportMissingImports]
from starlette.concurrency import run_in_threadpool  # pyright: ignore[reportMissingImports]

from core.logger import LOG_FILE, logger
from core.orchestrator import Orchestrator
from core.web_orchestrator import WebOrchestrator
from security.auth_check import is_target_allowed


BASE_DIR = Path(__file__).resolve().parent
templates = Jinja2Templates(directory=str(BASE_DIR / "templates"))

app = FastAPI(title="AI 渗透测试助手（v1.0版）")

app.mount(
    "/static",
    StaticFiles(directory=str(BASE_DIR / "static")),
    name="static",
)

orchestrator = Orchestrator()
web_orchestrator = WebOrchestrator()
REPORTS_DIR = Path(__file__).resolve().parent.parent / "data" / "reports"
REPORTS_DIR.mkdir(parents=True, exist_ok=True)

# 存储最近一次任务状态（简单内存存储）
_last_task_status: Dict[str, Any] = {}


def build_context(
    request: Request,
    target: str = "",
    error: str | None = None,
    result: Dict[str, Any] | None = None,
    render_partial: bool = False,
) -> Dict[str, Any]:
    return {
        "request": request,
        "target": target,
        "error": error,
        "result": result,
        "render_partial": render_partial,
        "last_task_status": _last_task_status,
    }


@app.get("/", response_class=HTMLResponse)
async def index(request: Request) -> HTMLResponse:
    ctx = build_context(request)
    return templates.TemplateResponse("index.html", ctx)


@app.post("/scan", response_class=HTMLResponse)
async def scan(request: Request, target: str = Form(...)) -> HTMLResponse:
    target = target.strip()
    is_hx = request.headers.get("HX-Request", "").lower() == "true"

    parsed = urlparse(target)
    is_url = parsed.scheme in {"http", "https"} and bool(parsed.netloc)
    auth_target = parsed.hostname if is_url else target

    # 更新任务状态
    _last_task_status.update({"status": "running", "target": target, "error": None})

    if not auth_target or not is_target_allowed(auth_target):
        _last_task_status.update({"status": "failed", "error": "目标不在授权列表或格式非法"})
        ctx = build_context(
            request=request,
            target=target,
            error="目标不在授权列表或格式非法，请检查 allowlist.txt。",
            render_partial=is_hx,
        )
        return templates.TemplateResponse("index.html", ctx)

    try:
        # URL 走多智能体 Web Orchestrator，其它情况保持原 nmap 流程
        if is_url:
            logger.info(f"[web] Detected URL target, using WebOrchestrator: {target}")
            result = await run_in_threadpool(web_orchestrator.run_full, target)
        else:
            logger.info(f"[web] Detected host/IP target, using Orchestrator: {target}")
            result = await run_in_threadpool(orchestrator.run_full, target)
        _last_task_status.update({"status": "success", "target": target, "result": result})
    except Exception as exc:  # 捕获意外错误，避免 500
        _last_task_status.update({"status": "failed", "error": str(exc)})
        logger.error(f"[web] Scan failed for {target}: {exc}")
        ctx = build_context(
            request=request,
            target=target,
            error=f"执行失败: {exc}",
            render_partial=is_hx,
        )
        return templates.TemplateResponse("index.html", ctx)

    ctx = build_context(
        request=request,
        target=target,
        result=result,
        render_partial=is_hx,
    )
    return templates.TemplateResponse("index.html", ctx)


@app.get("/logs", response_class=HTMLResponse)
async def logs_page(request: Request) -> HTMLResponse:
    """日志查看页面"""
    ctx = {"request": request}
    return templates.TemplateResponse("logs.html", ctx)


@app.get("/api/logs", response_class=HTMLResponse)
async def get_logs() -> str:
    """获取日志内容（用于 AJAX/HTMX 轮询）"""
    if not LOG_FILE.exists():
        return "日志文件不存在"
    try:
        with open(LOG_FILE, "r", encoding="utf-8") as f:
            lines = f.readlines()
            # 返回最后 500 行
            return "".join(lines[-500:])
    except Exception as e:
        return f"读取日志失败: {e}"


@app.get("/history", response_class=HTMLResponse)
async def history_page(request: Request) -> HTMLResponse:
    """历史报告列表页面"""
    reports = []
    if REPORTS_DIR.exists():
        for filepath in sorted(REPORTS_DIR.glob("*_report.md"), reverse=True):
            try:
                stat = filepath.stat()
                # 从文件名提取时间戳
                filename = filepath.name
                timestamp_str = filename.replace("_report.md", "")
                # 读取文件获取目标和摘要
                with open(filepath, "r", encoding="utf-8") as f:
                    content = f.read()
                    lines = content.splitlines()[:10]
                    target = "未知"
                    for line in lines:
                        if line.startswith("**目标**:"):
                            target = line.split(":", 1)[1].strip()
                            break
                    # 获取报告摘要（前50字，跳过标题）
                    summary = content[:200].replace("\n", " ").strip()[:50]
                    if len(summary) >= 50:
                        summary += "..."
            except Exception:
                continue
            reports.append({
                "filename": filename,
                "target": target,
                "timestamp": timestamp_str,
                "summary": summary,
                "size": stat.st_size,
            })
    ctx = {"request": request, "reports": reports}
    return templates.TemplateResponse("history.html", ctx)


@app.get("/view/{filename:path}")
async def view_report(request: Request, filename: str) -> HTMLResponse:
    """查看单个报告内容"""
    # 防止路径遍历
    if ".." in filename or "/" in filename or "\\" in filename:
        raise HTTPException(status_code=400, detail="非法文件名")
    filepath = REPORTS_DIR / filename
    if not filepath.exists() or not filepath.is_file():
        raise HTTPException(status_code=404, detail="报告不存在")
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"读取文件失败: {e}")
    ctx = {"request": request, "filename": filename, "content": content}
    return templates.TemplateResponse("view_report.html", ctx)


@app.get("/download/{filename:path}")
async def download_report(filename: str) -> FileResponse:
    """下载报告文件"""
    # 防止路径遍历
    if ".." in filename or "/" in filename or "\\" in filename:
        raise HTTPException(status_code=400, detail="非法文件名")
    filepath = REPORTS_DIR / filename
    if not filepath.exists() or not filepath.is_file():
        raise HTTPException(status_code=404, detail="报告不存在")
    return FileResponse(
        path=str(filepath),
        filename=filename,
        media_type="text/markdown",
    )

